#!/usr/bin/env bash
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—
#  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
#  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
#  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
#  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•  â•šâ•â•â•â•  â•šâ•â•  â•šâ•â•â•šâ•â•
#
#  DAVAI - Ğ´Ğ°Ğ²Ğ°Ğ¹, Ñ€Ğ°Ğ»ÑŒÑ„, Ğ´Ğ°Ğ²Ğ°Ğ¹!
#  Autonomous AI Coding Orchestrator with Interactive TUI
#
#  https://github.com/vajbratya/davai
#
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
set -Euo pipefail
shopt -s inherit_errexit 2>/dev/null || true

readonly VERSION="1.0.0"
readonly BRAND_NAME="DAVAI"
readonly SCRIPT_NAME="${0##*/}"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LAUNCH_DIR="$(pwd -P)"

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Configuration Defaults
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
: "${RALPH_ROOT:=$LAUNCH_DIR}"
: "${RALPH_DIR:=.ralph}"
: "${RALPH_MAX_ITER:=100}"
: "${RALPH_MAX_TRIES:=3}"
: "${RALPH_PARALLEL:=1}"
: "${RALPH_TIMEOUT:=600}"
: "${RALPH_SAFE:=1}"
: "${RALPH_VERIFY:=1}"
: "${RALPH_ISOLATE:=0}"
: "${RALPH_WEBHOOK:=}"
: "${RALPH_WEBHOOK_KIND:=auto}"
: "${RALPH_CLAUDE:=claude}"
: "${RALPH_MODEL:=}"
: "${RALPH_DASHBOARD:=1}"
: "${RALPH_DASHBOARD_PORT:=3333}"
: "${RALPH_DASHBOARD_HOST:=127.0.0.1}"
: "${RALPH_DASHBOARD_OPEN:=1}"
: "${RALPH_DASHBOARD_RESET_EVENTS:=1}"
: "${RALPH_PUBLIC:=0}"
: "${RALPH_TUNNEL:=auto}"
: "${RALPH_STREAM_AI:=1}"
: "${RALPH_DRY_RUN:=0}"
: "${RALPH_NO_COMMIT:=0}"
: "${RALPH_USAGE_TRACKING:=1}"
: "${RALPH_TOKEN_COST:=}"
: "${RALPH_WORKTREE_ROOT:=${HOME:-/tmp}/.ralph-worktrees}"

# TUI State
TUI_ACTIVE=0
TUI_REFRESH_RATE=1
CURRENT_VIEW="main"
SELECTED_INDEX=0
SCROLL_OFFSET=0
NOTIFICATION=""
NOTIFICATION_TYPE="info"
NOTIFICATION_TIMEOUT=0

# Onboarding State
ONBOARDING_STEP=0
ONBOARDING_COMPLETE=0
ONBOARDING_FILE=""

# Runtime State
EVENTS_FILE=""
DASHBOARD_PID=""
DASHBOARD_LOG=""
TUNNEL_PID=""
PUBLIC_URL=""
LOG_FILE=""
PRD_FILE=""
LOCK_FILE=""
LOCK_OWNED=0
TIMEOUT_CMD=()
WORKTREE_ROOT=""
SESSION_FILE=""
SESSION_WORKTREE=""
SESSION_BRANCH=""
PARALLEL_FAILS=0
STACK=""
PKG_MGR=""
TYPE_CMD=""
TEST_CMD=""
LINT_CMD=""
BUILD_CMD=""
FMT_CMD=""

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Terminal & Colors
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
setup_colors() {
    if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
        # Basic colors
        readonly BLACK=$'\e[30m' RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m'
        readonly BLUE=$'\e[34m' MAGENTA=$'\e[35m' CYAN=$'\e[36m' WHITE=$'\e[97m'
        readonly GRAY=$'\e[90m' LIGHT_GRAY=$'\e[37m'

        # Bright colors
        readonly BRIGHT_RED=$'\e[91m' BRIGHT_GREEN=$'\e[92m' BRIGHT_YELLOW=$'\e[93m'
        readonly BRIGHT_BLUE=$'\e[94m' BRIGHT_MAGENTA=$'\e[95m' BRIGHT_CYAN=$'\e[96m'

        # Background colors
        readonly BG_BLACK=$'\e[40m' BG_RED=$'\e[41m' BG_GREEN=$'\e[42m' BG_YELLOW=$'\e[43m'
        readonly BG_BLUE=$'\e[44m' BG_MAGENTA=$'\e[45m' BG_CYAN=$'\e[46m' BG_WHITE=$'\e[47m'
        readonly BG_GRAY=$'\e[100m' BG_BRIGHT_BLUE=$'\e[104m'

        # Styles
        readonly BOLD=$'\e[1m' DIM=$'\e[2m' ITALIC=$'\e[3m' UNDERLINE=$'\e[4m'
        readonly BLINK=$'\e[5m' REVERSE=$'\e[7m' HIDDEN=$'\e[8m' RESET=$'\e[0m'

        # Cursor & Screen
        readonly CLEAR_LINE=$'\e[2K' CLEAR_SCREEN=$'\e[2J' CLEAR_TO_END=$'\e[J'
        readonly HIDE_CURSOR=$'\e[?25l' SHOW_CURSOR=$'\e[?25h'
        readonly SAVE_CURSOR=$'\e[s' RESTORE_CURSOR=$'\e[u'
        readonly HOME=$'\e[H'

        # Alternative screen buffer
        readonly ALT_SCREEN_ON=$'\e[?1049h' ALT_SCREEN_OFF=$'\e[?1049l'
    else
        readonly BLACK='' RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' CYAN=''
        readonly WHITE='' GRAY='' LIGHT_GRAY=''
        readonly BRIGHT_RED='' BRIGHT_GREEN='' BRIGHT_YELLOW='' BRIGHT_BLUE=''
        readonly BRIGHT_MAGENTA='' BRIGHT_CYAN=''
        readonly BG_BLACK='' BG_RED='' BG_GREEN='' BG_YELLOW='' BG_BLUE=''
        readonly BG_MAGENTA='' BG_CYAN='' BG_WHITE='' BG_GRAY='' BG_BRIGHT_BLUE=''
        readonly BOLD='' DIM='' ITALIC='' UNDERLINE='' BLINK='' REVERSE=''
        readonly HIDDEN='' RESET='' CLEAR_LINE='' CLEAR_SCREEN='' CLEAR_TO_END=''
        readonly HIDE_CURSOR='' SHOW_CURSOR='' SAVE_CURSOR='' RESTORE_CURSOR=''
        readonly HOME='' ALT_SCREEN_ON='' ALT_SCREEN_OFF=''
    fi
}
setup_colors

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Terminal Utilities
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
get_terminal_size() {
    if command -v stty &>/dev/null; then
        read -r TERM_ROWS TERM_COLS < <(stty size 2>/dev/null || echo "24 80")
    else
        TERM_ROWS=${LINES:-24}
        TERM_COLS=${COLUMNS:-80}
    fi
    export TERM_ROWS TERM_COLS
}

move_cursor() {
    local row=$1 col=$2
    printf '\e[%d;%dH' "$row" "$col"
}

draw_box() {
    local row=$1 col=$2 width=$3 height=$4
    local title="${5:-}"
    local style="${6:-single}"

    local tl tr bl br h v
    case "$style" in
        double)
            tl="â•”" tr="â•—" bl="â•š" br="â•" h="â•" v="â•‘"
            ;;
        rounded)
            tl="â•­" tr="â•®" bl="â•°" br="â•¯" h="â”€" v="â”‚"
            ;;
        heavy)
            tl="â”" tr="â”“" bl="â”—" br="â”›" h="â”" v="â”ƒ"
            ;;
        *)
            tl="â”Œ" tr="â”" bl="â””" br="â”˜" h="â”€" v="â”‚"
            ;;
    esac

    # Top border
    move_cursor "$row" "$col"
    printf '%s%s' "$tl" "$(printf '%*s' "$((width-2))" '' | tr ' ' "$h")"
    printf '%s' "$tr"

    # Title if provided
    if [[ -n "$title" ]]; then
        local title_len=${#title}
        local title_pos=$(( (width - title_len - 2) / 2 + col ))
        move_cursor "$row" "$title_pos"
        printf ' %s%s%s ' "$BOLD" "$title" "$RESET"
    fi

    # Sides
    for ((i=1; i<height-1; i++)); do
        move_cursor "$((row+i))" "$col"
        printf '%s' "$v"
        move_cursor "$((row+i))" "$((col+width-1))"
        printf '%s' "$v"
    done

    # Bottom border
    move_cursor "$((row+height-1))" "$col"
    printf '%s%s%s' "$bl" "$(printf '%*s' "$((width-2))" '' | tr ' ' "$h")" "$br"
}

draw_horizontal_line() {
    local row=$1 col=$2 width=$3
    local char="${4:-â”€}"
    move_cursor "$row" "$col"
    printf '%*s' "$width" '' | tr ' ' "$char"
}

draw_vertical_line() {
    local row=$1 col=$2 height=$3
    local char="${4:-â”‚}"
    for ((i=0; i<height; i++)); do
        move_cursor "$((row+i))" "$col"
        printf '%s' "$char"
    done
}

center_text() {
    local text="$1" width="$2"
    local text_len=${#text}
    local padding=$(( (width - text_len) / 2 ))
    printf '%*s%s%*s' "$padding" '' "$text" "$((width - text_len - padding))" ''
}

right_align() {
    local text="$1" width="$2"
    printf '%*s' "$width" "$text"
}

truncate_text() {
    local text="$1" max_len="$2"
    if ((${#text} > max_len)); then
        printf '%sâ€¦' "${text:0:$((max_len-1))}"
    else
        printf '%s' "$text"
    fi
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# UI Components
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
draw_header() {
    local title="${1:-$BRAND_NAME}"
    local subtitle="${2:-Autonomous AI Coding Orchestrator}"

    get_terminal_size

    # Header background
    printf '%s' "$BG_BLUE$WHITE"
    move_cursor 1 1
    printf '%*s' "$TERM_COLS" ''
    move_cursor 2 1
    printf '%*s' "$TERM_COLS" ''
    move_cursor 3 1
    printf '%*s' "$TERM_COLS" ''

    # Title
    move_cursor 1 1
    printf '%s' "$BOLD"
    center_text "$title v$VERSION" "$TERM_COLS"

    # Subtitle
    move_cursor 2 1
    printf '%s' "$RESET$BG_BLUE$WHITE$DIM"
    center_text "$subtitle" "$TERM_COLS"

    # Status bar
    move_cursor 3 1
    printf '%s' "$RESET$BG_BLUE$BRIGHT_CYAN"
    local status_left=" $(date '+%H:%M:%S')"
    local status_right="Press ? for help "
    printf '%s' "$status_left"
    move_cursor 3 $((TERM_COLS - ${#status_right} + 1))
    printf '%s' "$status_right"

    printf '%s' "$RESET"
}

draw_footer() {
    get_terminal_size

    move_cursor "$TERM_ROWS" 1
    printf '%s%s%*s%s' "$BG_GRAY$WHITE" "" "$TERM_COLS" '' "$RESET"

    move_cursor "$TERM_ROWS" 2

    case "$CURRENT_VIEW" in
        main)
            printf '%s[â†‘â†“] Navigate  [Enter] Select  [q] Quit  [?] Help%s' "$WHITE" "$RESET"
            ;;
        run|execute)
            printf '%s[q] Stop  [p] Pause  [l] Logs  [s] Stories  [d] Dashboard%s' "$WHITE" "$RESET"
            ;;
        stories)
            printf '%s[â†‘â†“] Navigate  [Enter] Details  [r] Retry  [b] Block  [Esc] Back%s' "$WHITE" "$RESET"
            ;;
        logs)
            printf '%s[â†‘â†“/PgUp/PgDn] Scroll  [f] Filter  [c] Clear  [Esc] Back%s' "$WHITE" "$RESET"
            ;;
        settings)
            printf '%s[â†‘â†“] Navigate  [Enter] Edit  [r] Reset  [s] Save  [Esc] Back%s' "$WHITE" "$RESET"
            ;;
        *)
            printf '%s[Esc] Back  [q] Quit%s' "$WHITE" "$RESET"
            ;;
    esac
}

draw_notification() {
    [[ -z "$NOTIFICATION" ]] && return

    get_terminal_size
    local row=$((TERM_ROWS - 2))
    local msg_len=${#NOTIFICATION}
    local padding=4
    local box_width=$((msg_len + padding * 2))
    local col=$(( (TERM_COLS - box_width) / 2 ))

    local bg_color icon
    case "$NOTIFICATION_TYPE" in
        success) bg_color="$BG_GREEN$BLACK"; icon="âœ“" ;;
        error)   bg_color="$BG_RED$WHITE"; icon="âœ—" ;;
        warning) bg_color="$BG_YELLOW$BLACK"; icon="âš " ;;
        *)       bg_color="$BG_BLUE$WHITE"; icon="â„¹" ;;
    esac

    move_cursor "$row" "$col"
    printf '%s %s %s %s' "$bg_color" "$icon" "$NOTIFICATION" "$RESET"

    if ((NOTIFICATION_TIMEOUT > 0)); then
        ((NOTIFICATION_TIMEOUT--))
        ((NOTIFICATION_TIMEOUT == 0)) && NOTIFICATION=""
    fi
}

show_notification() {
    NOTIFICATION="$1"
    NOTIFICATION_TYPE="${2:-info}"
    NOTIFICATION_TIMEOUT="${3:-30}"
}

draw_menu() {
    local -n items=$1
    local selected=$2
    local start_row=$3
    local start_col=$4
    local width=$5
    local max_visible="${6:-10}"

    local count=${#items[@]}
    local visible_start=$SCROLL_OFFSET
    local visible_end=$((SCROLL_OFFSET + max_visible))
    ((visible_end > count)) && visible_end=$count

    for ((i=visible_start; i<visible_end; i++)); do
        local row=$((start_row + i - visible_start))
        move_cursor "$row" "$start_col"

        if ((i == selected)); then
            printf '%s%s â–¶ %-*s %s' "$BG_BRIGHT_BLUE$WHITE$BOLD" "" "$((width-4))" "${items[$i]}" "$RESET"
        else
            printf '   %-*s ' "$((width-4))" "${items[$i]}"
        fi
    done

    # Scroll indicators
    if ((visible_start > 0)); then
        move_cursor "$start_row" "$((start_col + width - 2))"
        printf '%sâ–²%s' "$DIM" "$RESET"
    fi
    if ((visible_end < count)); then
        move_cursor "$((start_row + max_visible - 1))" "$((start_col + width - 2))"
        printf '%sâ–¼%s' "$DIM" "$RESET"
    fi
}

draw_progress_bar() {
    local row=$1 col=$2 width=$3 percent=$4
    local label="${5:-}"

    local filled=$((percent * (width - 2) / 100))
    local empty=$((width - 2 - filled))

    move_cursor "$row" "$col"
    printf '['
    printf '%s%*s%s' "$GREEN" "$filled" '' "$RESET" | tr ' ' 'â–ˆ'
    printf '%s%*s%s' "$DIM" "$empty" '' "$RESET" | tr ' ' 'â–‘'
    printf '] %3d%%' "$percent"

    if [[ -n "$label" ]]; then
        printf ' %s%s%s' "$DIM" "$label" "$RESET"
    fi
}

draw_spinner() {
    local row=$1 col=$2
    local -a frames=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
    local frame_idx=$(( $(date +%s%N | cut -c1-10) % ${#frames[@]} ))

    move_cursor "$row" "$col"
    printf '%s%s%s' "$CYAN" "${frames[$frame_idx]}" "$RESET"
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Input Handling
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
read_key() {
    local key
    IFS= read -rsn1 -t "${1:-0.1}" key 2>/dev/null || true

    if [[ "$key" == $'\e' ]]; then
        read -rsn2 -t 0.01 key2 2>/dev/null || true
        key+="$key2"
    fi

    case "$key" in
        $'\e[A'|'k') echo "UP" ;;
        $'\e[B'|'j') echo "DOWN" ;;
        $'\e[C'|'l') echo "RIGHT" ;;
        $'\e[D'|'h') echo "LEFT" ;;
        $'\e[5~') echo "PGUP" ;;
        $'\e[6~') echo "PGDN" ;;
        $'\e[H'|$'\e[1~') echo "HOME" ;;
        $'\e[F'|$'\e[4~') echo "END" ;;
        $'\e') echo "ESC" ;;
        '') echo "ENTER" ;;
        ' ') echo "SPACE" ;;
        $'\x7f'|$'\b') echo "BACKSPACE" ;;
        $'\t') echo "TAB" ;;
        *) echo "$key" ;;
    esac
}

prompt_input() {
    local prompt="$1"
    local default="${2:-}"
    local row="${3:-}"
    local col="${4:-}"

    get_terminal_size
    [[ -z "$row" ]] && row=$((TERM_ROWS / 2))
    [[ -z "$col" ]] && col=10

    # Draw input box
    local box_width=$((TERM_COLS - 20))
    draw_box "$((row-1))" "$col" "$box_width" 5 "$prompt" "rounded"

    # Show default if present
    move_cursor "$((row+1))" "$((col+2))"
    printf '%s' "$SHOW_CURSOR"

    local input=""
    if [[ -n "$default" ]]; then
        input="$default"
        printf '%s' "$input"
    fi

    while true; do
        local key
        key=$(read_key 0.5)

        case "$key" in
            ENTER)
                printf '%s' "$HIDE_CURSOR"
                echo "$input"
                return 0
                ;;
            ESC)
                printf '%s' "$HIDE_CURSOR"
                return 1
                ;;
            BACKSPACE)
                if [[ -n "$input" ]]; then
                    input="${input%?}"
                    move_cursor "$((row+1))" "$((col+2))"
                    printf '%-*s' "$((box_width-4))" "$input"
                    move_cursor "$((row+1))" "$((col+2+${#input}))"
                fi
                ;;
            ""|UP|DOWN|LEFT|RIGHT|PGUP|PGDN|HOME|END|TAB|SPACE)
                [[ "$key" == "SPACE" ]] && { input+=" "; printf ' '; }
                ;;
            *)
                if [[ ${#key} -eq 1 && ${#input} -lt $((box_width-6)) ]]; then
                    input+="$key"
                    printf '%s' "$key"
                fi
                ;;
        esac
    done
}

prompt_confirm() {
    local prompt="$1"
    local default="${2:-n}"

    get_terminal_size
    local row=$((TERM_ROWS / 2))
    local col=10
    local box_width=$((TERM_COLS - 20))

    draw_box "$((row-1))" "$col" "$box_width" 5 "Confirm" "rounded"

    move_cursor "$((row+1))" "$((col+2))"
    printf '%s' "$prompt"

    move_cursor "$((row+2))" "$((col+2))"
    if [[ "$default" == "y" ]]; then
        printf '[%sY%s/n] ' "$BOLD" "$RESET"
    else
        printf '[y/%sN%s] ' "$BOLD" "$RESET"
    fi

    printf '%s' "$SHOW_CURSOR"

    while true; do
        local key
        key=$(read_key 0.5)

        case "$key" in
            y|Y) printf '%s' "$HIDE_CURSOR"; return 0 ;;
            n|N) printf '%s' "$HIDE_CURSOR"; return 1 ;;
            ENTER)
                printf '%s' "$HIDE_CURSOR"
                [[ "$default" == "y" ]] && return 0 || return 1
                ;;
            ESC)
                printf '%s' "$HIDE_CURSOR"
                return 1
                ;;
        esac
    done
}

prompt_select() {
    local prompt="$1"
    shift
    local -a options=("$@")
    local selected=0

    get_terminal_size
    local row=$((TERM_ROWS / 2 - ${#options[@]} / 2 - 2))
    local col=10
    local box_width=$((TERM_COLS - 20))
    local box_height=$((${#options[@]} + 4))

    draw_box "$row" "$col" "$box_width" "$box_height" "$prompt" "rounded"

    while true; do
        for ((i=0; i<${#options[@]}; i++)); do
            move_cursor "$((row + 2 + i))" "$((col + 2))"
            if ((i == selected)); then
                printf '%s â–¶ %s %s' "$BG_BRIGHT_BLUE$WHITE$BOLD" "${options[$i]}" "$RESET"
            else
                printf '   %s ' "${options[$i]}"
            fi
        done

        local key
        key=$(read_key 0.5)

        case "$key" in
            UP)
                ((selected > 0)) && ((selected--))
                ;;
            DOWN)
                ((selected < ${#options[@]} - 1)) && ((selected++))
                ;;
            ENTER)
                echo "$selected"
                return 0
                ;;
            ESC)
                return 1
                ;;
            [0-9])
                if ((key > 0 && key <= ${#options[@]})); then
                    echo "$((key - 1))"
                    return 0
                fi
                ;;
        esac
    done
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# View: Main Menu
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MAIN_MENU_ITEMS=(
    "ğŸš€  Start New Feature"
    "â–¶ï¸   Resume Session"
    "ğŸ“Š  View Status"
    "ğŸ“  View Stories"
    "ğŸ“œ  View Logs"
    "ğŸŒ  Open Dashboard"
    "âš™ï¸   Settings"
    "ğŸ”„  Reset Workspace"
    "â“  Help"
    "ğŸšª  Exit"
)

draw_main_menu() {
    get_terminal_size

    # Clear content area
    for ((i=4; i<TERM_ROWS-1; i++)); do
        move_cursor "$i" 1
        printf '%*s' "$TERM_COLS" ''
    done

    # ASCII Art Logo
    local logo_start=5
    move_cursor "$logo_start" 1
    printf '%s' "$CYAN"

    local logo=(
        "    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—"
        "    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘"
        "    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘"
        "    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘"
        "    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘"
        "    â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•  â•šâ•â•"
    )

    for ((i=0; i<${#logo[@]}; i++)); do
        move_cursor "$((logo_start + i))" "$(( (TERM_COLS - 46) / 2 ))"
        printf '%s' "${logo[$i]}"
    done
    printf '%s' "$RESET"

    # Session status
    local status_row=$((logo_start + 8))
    move_cursor "$status_row" 1

    local session_status="No active session"
    local session_color="$DIM"

    if [[ -f "$PRD_FILE" ]]; then
        local feature_name total_stories done_stories
        feature_name=$(jq -r '.feature // "unknown"' "$PRD_FILE" 2>/dev/null || echo "unknown")
        total_stories=$(jq '.stories | length' "$PRD_FILE" 2>/dev/null || echo 0)
        done_stories=$(jq '[.stories[] | select(.done)] | length' "$PRD_FILE" 2>/dev/null || echo 0)
        session_status="Active: $feature_name ($done_stories/$total_stories stories)"
        session_color="$GREEN"
    fi

    printf '%s' "$session_color"
    center_text "[ $session_status ]" "$TERM_COLS"
    printf '%s' "$RESET"

    # Menu
    local menu_row=$((status_row + 3))
    local menu_width=40
    local menu_col=$(( (TERM_COLS - menu_width) / 2 ))

    draw_box "$((menu_row - 1))" "$((menu_col - 2))" "$((menu_width + 4))" "$((${#MAIN_MENU_ITEMS[@]} + 2))" "" "rounded"

    for ((i=0; i<${#MAIN_MENU_ITEMS[@]}; i++)); do
        move_cursor "$((menu_row + i))" "$menu_col"
        if ((i == SELECTED_INDEX)); then
            printf '%s%s %-*s %s' "$BG_BRIGHT_BLUE$WHITE$BOLD" "" "$((menu_width - 2))" "${MAIN_MENU_ITEMS[$i]}" "$RESET"
        else
            printf '  %-*s ' "$((menu_width - 4))" "${MAIN_MENU_ITEMS[$i]}"
        fi
    done
}

handle_main_menu_input() {
    local key="$1"

    case "$key" in
        UP)
            ((SELECTED_INDEX > 0)) && ((SELECTED_INDEX--))
            ;;
        DOWN)
            ((SELECTED_INDEX < ${#MAIN_MENU_ITEMS[@]} - 1)) && ((SELECTED_INDEX++))
            ;;
        ENTER)
            case $SELECTED_INDEX in
                0) start_new_feature ;;
                1) resume_session ;;
                2) CURRENT_VIEW="status" ;;
                3) CURRENT_VIEW="stories" ;;
                4) CURRENT_VIEW="logs" ;;
                5) open_dashboard ;;
                6) CURRENT_VIEW="settings" ;;
                7) reset_workspace ;;
                8) CURRENT_VIEW="help" ;;
                9) return 1 ;;
            esac
            ;;
        q|Q)
            return 1
            ;;
        '?')
            CURRENT_VIEW="help"
            ;;
    esac
    return 0
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# View: Stories
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
draw_stories_view() {
    get_terminal_size

    # Clear content area
    for ((i=4; i<TERM_ROWS-1; i++)); do
        move_cursor "$i" 1
        printf '%*s' "$TERM_COLS" ''
    done

    if [[ ! -f "$PRD_FILE" ]]; then
        move_cursor "$((TERM_ROWS / 2))" 1
        printf '%s' "$DIM"
        center_text "No active session. Start a new feature first." "$TERM_COLS"
        printf '%s' "$RESET"
        return
    fi

    # Title
    move_cursor 5 2
    printf '%s%s Stories %s' "$BOLD" "ğŸ“" "$RESET"

    local feature_name
    feature_name=$(jq -r '.feature // "unknown"' "$PRD_FILE")
    printf '%s(%s)%s' "$DIM" "$feature_name" "$RESET"

    # Stats
    local total done_count blocked running pending
    total=$(jq '.stories | length' "$PRD_FILE")
    done_count=$(jq '[.stories[] | select(.done)] | length' "$PRD_FILE")
    blocked=$(jq '[.stories[] | select(.blocked)] | length' "$PRD_FILE")
    running=$(jq '[.stories[] | select(.running)] | length' "$PRD_FILE")
    pending=$((total - done_count - blocked))

    move_cursor 5 $((TERM_COLS - 50))
    printf '%sâœ“ %d%s  ' "$GREEN" "$done_count" "$RESET"
    printf '%sâ–¶ %d%s  ' "$BLUE" "$running" "$RESET"
    printf '%sâ—‹ %d%s  ' "$GRAY" "$pending" "$RESET"
    printf '%sâœ— %d%s' "$RED" "$blocked" "$RESET"

    # Progress bar
    local pct=0
    ((total > 0)) && pct=$((done_count * 100 / total))
    draw_progress_bar 7 2 "$((TERM_COLS - 20))" "$pct" ""

    draw_horizontal_line 8 1 "$TERM_COLS" "â”€"

    # Stories list
    local list_start=9
    local list_height=$((TERM_ROWS - list_start - 2))
    local max_visible=$((list_height))

    local -a story_lines=()
    while IFS= read -r line; do
        story_lines+=("$line")
    done < <(jq -r '.stories[] | "\(.id)|\(.title)|\(.done)|\(.blocked)|\(.running)|\(.tries)"' "$PRD_FILE" 2>/dev/null)

    local story_count=${#story_lines[@]}

    # Adjust scroll offset
    if ((SELECTED_INDEX >= SCROLL_OFFSET + max_visible)); then
        SCROLL_OFFSET=$((SELECTED_INDEX - max_visible + 1))
    elif ((SELECTED_INDEX < SCROLL_OFFSET)); then
        SCROLL_OFFSET=$SELECTED_INDEX
    fi

    for ((i=0; i<max_visible && i+SCROLL_OFFSET<story_count; i++)); do
        local row=$((list_start + i))
        local idx=$((i + SCROLL_OFFSET))
        local line="${story_lines[$idx]}"

        IFS='|' read -r sid stitle sdone sblocked srunning stries <<< "$line"

        move_cursor "$row" 2

        # Status icon
        local icon color
        if [[ "$srunning" == "true" ]]; then
            icon="â–¶" color="$BLUE"
        elif [[ "$sdone" == "true" ]]; then
            icon="âœ“" color="$GREEN"
        elif [[ "$sblocked" == "true" ]]; then
            icon="âœ—" color="$RED"
        elif [[ "$stries" -gt 0 ]]; then
            icon="â—" color="$YELLOW"
        else
            icon="â—‹" color="$GRAY"
        fi

        local line_text
        line_text=$(printf '%s %s: %s' "$icon" "$sid" "$(truncate_text "$stitle" $((TERM_COLS - 20)))")

        if ((idx == SELECTED_INDEX)); then
            printf '%s%s%-*s%s' "$BG_BRIGHT_BLUE$WHITE$BOLD" "" "$((TERM_COLS - 2))" "$line_text" "$RESET"
        else
            printf '%s%s%-*s%s' "$color" "" "$((TERM_COLS - 2))" "$line_text" "$RESET"
        fi

        # Show tries count
        if [[ "$stries" -gt 0 && "$sdone" != "true" ]]; then
            move_cursor "$row" $((TERM_COLS - 12))
            printf '%s(%d tries)%s' "$YELLOW" "$stries" "$RESET"
        fi
    done

    # Scroll indicators
    if ((SCROLL_OFFSET > 0)); then
        move_cursor "$list_start" "$((TERM_COLS - 1))"
        printf '%sâ–²%s' "$DIM" "$RESET"
    fi
    if ((SCROLL_OFFSET + max_visible < story_count)); then
        move_cursor "$((list_start + max_visible - 1))" "$((TERM_COLS - 1))"
        printf '%sâ–¼%s' "$DIM" "$RESET"
    fi
}

handle_stories_input() {
    local key="$1"

    local story_count
    story_count=$(jq '.stories | length' "$PRD_FILE" 2>/dev/null || echo 0)

    case "$key" in
        UP)
            ((SELECTED_INDEX > 0)) && ((SELECTED_INDEX--))
            ;;
        DOWN)
            ((SELECTED_INDEX < story_count - 1)) && ((SELECTED_INDEX++))
            ;;
        ENTER)
            show_story_details "$SELECTED_INDEX"
            ;;
        r|R)
            retry_story "$SELECTED_INDEX"
            ;;
        b|B)
            toggle_story_blocked "$SELECTED_INDEX"
            ;;
        ESC|q)
            CURRENT_VIEW="main"
            SELECTED_INDEX=0
            SCROLL_OFFSET=0
            ;;
    esac
    return 0
}

show_story_details() {
    local idx="$1"

    local story
    story=$(jq -c ".stories[$idx]" "$PRD_FILE")
    [[ -z "$story" || "$story" == "null" ]] && return

    get_terminal_size

    local box_width=$((TERM_COLS - 10))
    local box_height=$((TERM_ROWS - 10))
    local box_row=5
    local box_col=5

    # Draw detail box
    draw_box "$box_row" "$box_col" "$box_width" "$box_height" "Story Details" "double"

    local content_row=$((box_row + 2))
    local content_col=$((box_col + 2))
    local max_width=$((box_width - 4))

    # ID and Title
    local sid stitle swhy
    sid=$(echo "$story" | jq -r '.id')
    stitle=$(echo "$story" | jq -r '.title')
    swhy=$(echo "$story" | jq -r '.why // "N/A"')

    move_cursor "$content_row" "$content_col"
    printf '%s%s%s: %s' "$BOLD$CYAN" "$sid" "$RESET" "$stitle"

    # Why
    ((content_row += 2))
    move_cursor "$content_row" "$content_col"
    printf '%sWhy:%s %s' "$BOLD" "$RESET" "$(truncate_text "$swhy" $((max_width - 5)))"

    # Status
    ((content_row += 2))
    move_cursor "$content_row" "$content_col"
    printf '%sStatus:%s ' "$BOLD" "$RESET"

    local sdone sblocked srunning stries
    sdone=$(echo "$story" | jq -r '.done')
    sblocked=$(echo "$story" | jq -r '.blocked')
    srunning=$(echo "$story" | jq -r '.running')
    stries=$(echo "$story" | jq -r '.tries // 0')

    if [[ "$srunning" == "true" ]]; then
        printf '%sâ–¶ Running%s' "$BLUE" "$RESET"
    elif [[ "$sdone" == "true" ]]; then
        printf '%sâœ“ Complete%s' "$GREEN" "$RESET"
    elif [[ "$sblocked" == "true" ]]; then
        printf '%sâœ— Blocked%s' "$RED" "$RESET"
    else
        printf '%sâ—‹ Pending%s' "$GRAY" "$RESET"
    fi
    printf '  (Tries: %s)' "$stries"

    # Criteria
    ((content_row += 2))
    move_cursor "$content_row" "$content_col"
    printf '%sCriteria:%s' "$BOLD" "$RESET"

    local -a criteria=()
    while IFS= read -r c; do
        criteria+=("$c")
    done < <(echo "$story" | jq -r '.criteria[]?' 2>/dev/null)

    for ((i=0; i<${#criteria[@]} && content_row < box_row + box_height - 4; i++)); do
        ((content_row++))
        move_cursor "$content_row" "$content_col"
        printf '  â€¢ %s' "$(truncate_text "${criteria[$i]}" $((max_width - 4)))"
    done

    # Files
    ((content_row += 2))
    move_cursor "$content_row" "$content_col"
    printf '%sFiles:%s ' "$BOLD" "$RESET"
    local files
    files=$(echo "$story" | jq -r '.files | join(", ")' 2>/dev/null || echo "N/A")
    printf '%s' "$(truncate_text "$files" $((max_width - 8)))"

    # Dependencies
    ((content_row += 1))
    move_cursor "$content_row" "$content_col"
    printf '%sDeps:%s ' "$BOLD" "$RESET"
    local deps
    deps=$(echo "$story" | jq -r '.deps | join(", ")' 2>/dev/null || echo "None")
    printf '%s' "${deps:-None}"

    # Notes
    local snotes
    snotes=$(echo "$story" | jq -r '.notes // ""')
    if [[ -n "$snotes" ]]; then
        ((content_row += 2))
        move_cursor "$content_row" "$content_col"
        printf '%sNotes:%s %s' "$BOLD" "$RESET" "$(truncate_text "$snotes" $((max_width - 8)))"
    fi

    # Close button
    move_cursor "$((box_row + box_height - 2))" "$content_col"
    printf '%sPress any key to close%s' "$DIM" "$RESET"

    read_key 30
}

retry_story() {
    local idx="$1"

    local sid
    sid=$(jq -r ".stories[$idx].id" "$PRD_FILE" 2>/dev/null)
    [[ -z "$sid" || "$sid" == "null" ]] && return

    if prompt_confirm "Reset tries for story $sid?"; then
        jq_inplace "$PRD_FILE" --argjson idx "$idx" '
            .stories[$idx].tries = 0 |
            .stories[$idx].blocked = false |
            .stories[$idx].running = false
        '
        show_notification "Story $sid reset for retry" "success" 30
    fi
}

toggle_story_blocked() {
    local idx="$1"

    local sid sblocked
    sid=$(jq -r ".stories[$idx].id" "$PRD_FILE" 2>/dev/null)
    sblocked=$(jq -r ".stories[$idx].blocked" "$PRD_FILE" 2>/dev/null)
    [[ -z "$sid" || "$sid" == "null" ]] && return

    if [[ "$sblocked" == "true" ]]; then
        jq_inplace "$PRD_FILE" --argjson idx "$idx" '.stories[$idx].blocked = false'
        show_notification "Story $sid unblocked" "success" 30
    else
        jq_inplace "$PRD_FILE" --argjson idx "$idx" '.stories[$idx].blocked = true'
        show_notification "Story $sid blocked" "warning" 30
    fi
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# View: Status
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
draw_status_view() {
    get_terminal_size

    # Clear content area
    for ((i=4; i<TERM_ROWS-1; i++)); do
        move_cursor "$i" 1
        printf '%*s' "$TERM_COLS" ''
    done

    if [[ ! -f "$PRD_FILE" ]]; then
        move_cursor "$((TERM_ROWS / 2))" 1
        printf '%s' "$DIM"
        center_text "No active session. Start a new feature first." "$TERM_COLS"
        printf '%s' "$RESET"
        return
    fi

    local row=5
    local col=4
    local box_width=$((TERM_COLS / 2 - 6))

    # Left panel - Session Info
    draw_box "$row" "$col" "$box_width" 12 "Session Info" "rounded"

    local feature_name branch created
    feature_name=$(jq -r '.feature // "unknown"' "$PRD_FILE")
    branch=$(jq -r '.branch // "unknown"' "$PRD_FILE")
    created=$(jq -r '.created // "unknown"' "$PRD_FILE")

    move_cursor "$((row+2))" "$((col+2))"
    printf '%sFeature:%s %s' "$BOLD" "$RESET" "$(truncate_text "$feature_name" $((box_width-12)))"

    move_cursor "$((row+3))" "$((col+2))"
    printf '%sBranch:%s  %s' "$BOLD" "$RESET" "$(truncate_text "$branch" $((box_width-12)))"

    move_cursor "$((row+4))" "$((col+2))"
    printf '%sCreated:%s %s' "$BOLD" "$RESET" "$created"

    move_cursor "$((row+5))" "$((col+2))"
    printf '%sStack:%s   %s' "$BOLD" "$RESET" "${STACK:-unknown}"

    move_cursor "$((row+6))" "$((col+2))"
    printf '%sPackage:%s %s' "$BOLD" "$RESET" "${PKG_MGR:-unknown}"

    move_cursor "$((row+8))" "$((col+2))"
    printf '%sVerify:%s  %s' "$BOLD" "$RESET"
    [[ -n "$TYPE_CMD" ]] && printf 'Type ' || printf '%s- %s' "$DIM" "$RESET"
    [[ -n "$TEST_CMD" ]] && printf 'Test ' || true
    [[ -n "$LINT_CMD" ]] && printf 'Lint' || true

    # Right panel - Progress Stats
    local right_col=$((TERM_COLS / 2 + 2))
    draw_box "$row" "$right_col" "$box_width" 12 "Progress" "rounded"

    local total done_count blocked running pending
    total=$(jq '.stories | length' "$PRD_FILE")
    done_count=$(jq '[.stories[] | select(.done)] | length' "$PRD_FILE")
    blocked=$(jq '[.stories[] | select(.blocked)] | length' "$PRD_FILE")
    running=$(jq '[.stories[] | select(.running)] | length' "$PRD_FILE")
    pending=$((total - done_count - blocked))

    local pct=0
    ((total > 0)) && pct=$((done_count * 100 / total))

    move_cursor "$((row+2))" "$((right_col+2))"
    printf '%sTotal Stories:%s %d' "$BOLD" "$RESET" "$total"

    move_cursor "$((row+4))" "$((right_col+2))"
    printf '%sâœ“%s Completed:  %d' "$GREEN" "$RESET" "$done_count"

    move_cursor "$((row+5))" "$((right_col+2))"
    printf '%sâ–¶%s Running:    %d' "$BLUE" "$RESET" "$running"

    move_cursor "$((row+6))" "$((right_col+2))"
    printf '%sâ—‹%s Pending:    %d' "$GRAY" "$RESET" "$pending"

    move_cursor "$((row+7))" "$((right_col+2))"
    printf '%sâœ—%s Blocked:    %d' "$RED" "$RESET" "$blocked"

    move_cursor "$((row+9))" "$((right_col+2))"
    draw_progress_bar "$((row+9))" "$((right_col+2))" "$((box_width-4))" "$pct"

    # Usage statistics
    local usage_row=$((row + 14))
    draw_box "$usage_row" "$col" "$((TERM_COLS - 8))" 6 "Usage Statistics" "rounded"

    if [[ -f "$RALPH_DIR/usage.jsonl" ]]; then
        local total_tokens total_cost
        total_tokens=$(jq -s '[.[].total_tokens] | add // 0' "$RALPH_DIR/usage.jsonl" 2>/dev/null || echo 0)
        total_cost=$(jq -s '[.[].est_cost | select(. != "") | tonumber] | add // 0' "$RALPH_DIR/usage.jsonl" 2>/dev/null || echo 0)

        move_cursor "$((usage_row+2))" "$((col+2))"
        printf '%sEstimated Tokens:%s %s' "$BOLD" "$RESET" "$total_tokens"

        move_cursor "$((usage_row+3))" "$((col+2))"
        printf '%sEstimated Cost:%s  $%s' "$BOLD" "$RESET" "$total_cost"
    else
        move_cursor "$((usage_row+2))" "$((col+2))"
        printf '%sNo usage data available%s' "$DIM" "$RESET"
    fi

    # Recent activity
    local activity_row=$((usage_row + 8))
    local remaining_height=$((TERM_ROWS - activity_row - 2))

    if ((remaining_height > 4)); then
        draw_box "$activity_row" "$col" "$((TERM_COLS - 8))" "$remaining_height" "Recent Activity" "rounded"

        if [[ -f "$RALPH_DIR/memory.md" ]]; then
            local line_num=0
            while IFS= read -r line && ((line_num < remaining_height - 3)); do
                ((line_num++))
                move_cursor "$((activity_row + 1 + line_num))" "$((col+2))"
                printf '%s' "$(truncate_text "$line" $((TERM_COLS - 14)))"
            done < <(tail -$((remaining_height - 3)) "$RALPH_DIR/memory.md" 2>/dev/null)
        else
            move_cursor "$((activity_row+2))" "$((col+2))"
            printf '%sNo activity recorded yet%s' "$DIM" "$RESET"
        fi
    fi
}

handle_status_input() {
    local key="$1"

    case "$key" in
        ESC|q|ENTER)
            CURRENT_VIEW="main"
            SELECTED_INDEX=0
            ;;
        r|R)
            # Refresh
            detect_stack
            ;;
    esac
    return 0
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# View: Logs
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LOG_SCROLL_OFFSET=0
LOG_FILTER=""

draw_logs_view() {
    get_terminal_size

    # Clear content area
    for ((i=4; i<TERM_ROWS-1; i++)); do
        move_cursor "$i" 1
        printf '%*s' "$TERM_COLS" ''
    done

    local log_file="$RALPH_DIR/ralph.log"

    # Title bar
    move_cursor 5 2
    printf '%s%s Execution Logs %s' "$BOLD" "ğŸ“œ" "$RESET"

    if [[ -n "$LOG_FILTER" ]]; then
        printf '%s(filter: %s)%s' "$DIM" "$LOG_FILTER" "$RESET"
    fi

    move_cursor 5 $((TERM_COLS - 30))
    if [[ -f "$log_file" ]]; then
        local line_count
        line_count=$(wc -l < "$log_file" 2>/dev/null || echo 0)
        printf '%s%d lines%s' "$DIM" "$line_count" "$RESET"
    fi

    draw_horizontal_line 6 1 "$TERM_COLS" "â”€"

    # Log content
    local content_start=7
    local content_height=$((TERM_ROWS - content_start - 2))

    if [[ ! -f "$log_file" ]]; then
        move_cursor "$((content_start + content_height / 2))" 1
        printf '%s' "$DIM"
        center_text "No logs available yet. Start a feature to see logs." "$TERM_COLS"
        printf '%s' "$RESET"
        return
    fi

    local -a log_lines=()
    local line_num=0

    while IFS= read -r line; do
        if [[ -z "$LOG_FILTER" ]] || [[ "$line" == *"$LOG_FILTER"* ]]; then
            log_lines+=("$line")
        fi
    done < "$log_file"

    local total_lines=${#log_lines[@]}
    local max_scroll=$((total_lines - content_height))
    ((max_scroll < 0)) && max_scroll=0
    ((LOG_SCROLL_OFFSET > max_scroll)) && LOG_SCROLL_OFFSET=$max_scroll
    ((LOG_SCROLL_OFFSET < 0)) && LOG_SCROLL_OFFSET=0

    for ((i=0; i<content_height && i+LOG_SCROLL_OFFSET<total_lines; i++)); do
        local row=$((content_start + i))
        local line="${log_lines[$((i + LOG_SCROLL_OFFSET))]}"

        move_cursor "$row" 2

        # Color based on log level
        local color="$RESET"
        if [[ "$line" == *"[ERR]"* ]] || [[ "$line" == *"ERROR"* ]]; then
            color="$RED"
        elif [[ "$line" == *"[WARN]"* ]] || [[ "$line" == *"WARNING"* ]]; then
            color="$YELLOW"
        elif [[ "$line" == *"[OK]"* ]] || [[ "$line" == *"SUCCESS"* ]]; then
            color="$GREEN"
        elif [[ "$line" == *"[DEBUG]"* ]]; then
            color="$DIM"
        fi

        printf '%s%-*s%s' "$color" "$((TERM_COLS - 4))" "$(truncate_text "$line" $((TERM_COLS - 4)))" "$RESET"
    done

    # Scroll position indicator
    if ((total_lines > content_height)); then
        local scroll_pct=$((LOG_SCROLL_OFFSET * 100 / max_scroll))
        move_cursor "$((TERM_ROWS - 2))" $((TERM_COLS - 15))
        printf '%s[%3d%%]%s' "$DIM" "$scroll_pct" "$RESET"
    fi
}

handle_logs_input() {
    local key="$1"

    local log_file="$RALPH_DIR/ralph.log"
    local total_lines=0
    [[ -f "$log_file" ]] && total_lines=$(wc -l < "$log_file" 2>/dev/null || echo 0)

    get_terminal_size
    local content_height=$((TERM_ROWS - 9))
    local max_scroll=$((total_lines - content_height))
    ((max_scroll < 0)) && max_scroll=0

    case "$key" in
        UP)
            ((LOG_SCROLL_OFFSET > 0)) && ((LOG_SCROLL_OFFSET--))
            ;;
        DOWN)
            ((LOG_SCROLL_OFFSET < max_scroll)) && ((LOG_SCROLL_OFFSET++))
            ;;
        PGUP)
            LOG_SCROLL_OFFSET=$((LOG_SCROLL_OFFSET - content_height))
            ((LOG_SCROLL_OFFSET < 0)) && LOG_SCROLL_OFFSET=0
            ;;
        PGDN)
            LOG_SCROLL_OFFSET=$((LOG_SCROLL_OFFSET + content_height))
            ((LOG_SCROLL_OFFSET > max_scroll)) && LOG_SCROLL_OFFSET=$max_scroll
            ;;
        HOME)
            LOG_SCROLL_OFFSET=0
            ;;
        END)
            LOG_SCROLL_OFFSET=$max_scroll
            ;;
        f|F)
            local filter
            if filter=$(prompt_input "Filter logs" "$LOG_FILTER"); then
                LOG_FILTER="$filter"
                LOG_SCROLL_OFFSET=0
            fi
            ;;
        c|C)
            if prompt_confirm "Clear all logs?"; then
                : > "$log_file"
                LOG_SCROLL_OFFSET=0
                show_notification "Logs cleared" "success" 30
            fi
            ;;
        ESC|q)
            CURRENT_VIEW="main"
            SELECTED_INDEX=0
            LOG_SCROLL_OFFSET=0
            LOG_FILTER=""
            ;;
    esac
    return 0
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# View: Settings
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SETTINGS_ITEMS=(
    "Max Iterations|RALPH_MAX_ITER|$RALPH_MAX_ITER"
    "Max Tries per Story|RALPH_MAX_TRIES|$RALPH_MAX_TRIES"
    "Parallel Agents|RALPH_PARALLEL|$RALPH_PARALLEL"
    "Timeout (seconds)|RALPH_TIMEOUT|$RALPH_TIMEOUT"
    "Safe Mode|RALPH_SAFE|$RALPH_SAFE"
    "Verify (typecheck/tests)|RALPH_VERIFY|$RALPH_VERIFY"
    "Isolate (worktree)|RALPH_ISOLATE|$RALPH_ISOLATE"
    "Dashboard|RALPH_DASHBOARD|$RALPH_DASHBOARD"
    "Dashboard Port|RALPH_DASHBOARD_PORT|$RALPH_DASHBOARD_PORT"
    "Auto-open Dashboard|RALPH_DASHBOARD_OPEN|$RALPH_DASHBOARD_OPEN"
    "Public Tunnel|RALPH_PUBLIC|$RALPH_PUBLIC"
    "Stream AI Output|RALPH_STREAM_AI|$RALPH_STREAM_AI"
    "No Commit|RALPH_NO_COMMIT|$RALPH_NO_COMMIT"
    "Usage Tracking|RALPH_USAGE_TRACKING|$RALPH_USAGE_TRACKING"
    "Claude Binary|RALPH_CLAUDE|$RALPH_CLAUDE"
    "Model Override|RALPH_MODEL|${RALPH_MODEL:-auto}"
)

draw_settings_view() {
    get_terminal_size

    # Clear content area
    for ((i=4; i<TERM_ROWS-1; i++)); do
        move_cursor "$i" 1
        printf '%*s' "$TERM_COLS" ''
    done

    # Title
    move_cursor 5 2
    printf '%s%s Settings %s' "$BOLD" "âš™ï¸ " "$RESET"

    draw_horizontal_line 6 1 "$TERM_COLS" "â”€"

    local content_start=7
    local content_height=$((TERM_ROWS - content_start - 3))
    local max_visible=$content_height

    # Update settings values
    SETTINGS_ITEMS=(
        "Max Iterations|RALPH_MAX_ITER|$RALPH_MAX_ITER"
        "Max Tries per Story|RALPH_MAX_TRIES|$RALPH_MAX_TRIES"
        "Parallel Agents|RALPH_PARALLEL|$RALPH_PARALLEL"
        "Timeout (seconds)|RALPH_TIMEOUT|$RALPH_TIMEOUT"
        "Safe Mode|RALPH_SAFE|$RALPH_SAFE"
        "Verify (typecheck/tests)|RALPH_VERIFY|$RALPH_VERIFY"
        "Isolate (worktree)|RALPH_ISOLATE|$RALPH_ISOLATE"
        "Dashboard|RALPH_DASHBOARD|$RALPH_DASHBOARD"
        "Dashboard Port|RALPH_DASHBOARD_PORT|$RALPH_DASHBOARD_PORT"
        "Auto-open Dashboard|RALPH_DASHBOARD_OPEN|$RALPH_DASHBOARD_OPEN"
        "Public Tunnel|RALPH_PUBLIC|$RALPH_PUBLIC"
        "Stream AI Output|RALPH_STREAM_AI|$RALPH_STREAM_AI"
        "No Commit|RALPH_NO_COMMIT|$RALPH_NO_COMMIT"
        "Usage Tracking|RALPH_USAGE_TRACKING|$RALPH_USAGE_TRACKING"
        "Claude Binary|RALPH_CLAUDE|$RALPH_CLAUDE"
        "Model Override|RALPH_MODEL|${RALPH_MODEL:-auto}"
    )

    local setting_count=${#SETTINGS_ITEMS[@]}

    # Adjust scroll
    if ((SELECTED_INDEX >= SCROLL_OFFSET + max_visible)); then
        SCROLL_OFFSET=$((SELECTED_INDEX - max_visible + 1))
    elif ((SELECTED_INDEX < SCROLL_OFFSET)); then
        SCROLL_OFFSET=$SELECTED_INDEX
    fi

    local label_width=25
    local value_width=$((TERM_COLS - label_width - 10))

    for ((i=0; i<max_visible && i+SCROLL_OFFSET<setting_count; i++)); do
        local row=$((content_start + i))
        local idx=$((i + SCROLL_OFFSET))

        IFS='|' read -r label var value <<< "${SETTINGS_ITEMS[$idx]}"

        move_cursor "$row" 2

        if ((idx == SELECTED_INDEX)); then
            printf '%s%s' "$BG_BRIGHT_BLUE$WHITE$BOLD" ""
        fi

        printf '%-*s' "$label_width" "$label"

        # Format value display
        if [[ "$value" == "0" ]]; then
            printf '%sâœ— Off%s' "$RED" "$RESET"
        elif [[ "$value" == "1" ]]; then
            printf '%sâœ“ On%s' "$GREEN" "$RESET"
        else
            printf '%s' "$value"
        fi

        if ((idx == SELECTED_INDEX)); then
            printf '%*s%s' "$((TERM_COLS - label_width - ${#value} - 6))" '' "$RESET"
        fi
    done

    # Help text
    move_cursor "$((TERM_ROWS - 3))" 2
    printf '%sPress Enter to edit, Space to toggle, r to reset to defaults%s' "$DIM" "$RESET"
}

handle_settings_input() {
    local key="$1"

    local setting_count=${#SETTINGS_ITEMS[@]}

    case "$key" in
        UP)
            ((SELECTED_INDEX > 0)) && ((SELECTED_INDEX--))
            ;;
        DOWN)
            ((SELECTED_INDEX < setting_count - 1)) && ((SELECTED_INDEX++))
            ;;
        ENTER|SPACE)
            edit_setting "$SELECTED_INDEX"
            ;;
        r|R)
            if prompt_confirm "Reset all settings to defaults?"; then
                reset_settings_to_defaults
                show_notification "Settings reset to defaults" "success" 30
            fi
            ;;
        s|S)
            save_settings
            show_notification "Settings saved" "success" 30
            ;;
        ESC|q)
            CURRENT_VIEW="main"
            SELECTED_INDEX=0
            SCROLL_OFFSET=0
            ;;
    esac
    return 0
}

edit_setting() {
    local idx="$1"

    IFS='|' read -r label var value <<< "${SETTINGS_ITEMS[$idx]}"

    # Toggle boolean settings with space
    if [[ "$value" == "0" || "$value" == "1" ]]; then
        if [[ "$value" == "0" ]]; then
            eval "$var=1"
        else
            eval "$var=0"
        fi
        return
    fi

    # Prompt for new value
    local new_value
    if new_value=$(prompt_input "Set $label" "$value"); then
        eval "$var=\"\$new_value\""
    fi
}

reset_settings_to_defaults() {
    RALPH_MAX_ITER=100
    RALPH_MAX_TRIES=3
    RALPH_PARALLEL=1
    RALPH_TIMEOUT=600
    RALPH_SAFE=1
    RALPH_VERIFY=1
    RALPH_ISOLATE=0
    RALPH_DASHBOARD=1
    RALPH_DASHBOARD_PORT=3333
    RALPH_DASHBOARD_OPEN=1
    RALPH_PUBLIC=0
    RALPH_STREAM_AI=1
    RALPH_NO_COMMIT=0
    RALPH_USAGE_TRACKING=1
    RALPH_CLAUDE="claude"
    RALPH_MODEL=""
}

save_settings() {
    local config_file="$RALPH_DIR/config.sh"
    mkdir -p "$RALPH_DIR"

    cat > "$config_file" << EOF
# RALPH Configuration - Generated $(date)
export RALPH_MAX_ITER=$RALPH_MAX_ITER
export RALPH_MAX_TRIES=$RALPH_MAX_TRIES
export RALPH_PARALLEL=$RALPH_PARALLEL
export RALPH_TIMEOUT=$RALPH_TIMEOUT
export RALPH_SAFE=$RALPH_SAFE
export RALPH_VERIFY=$RALPH_VERIFY
export RALPH_ISOLATE=$RALPH_ISOLATE
export RALPH_DASHBOARD=$RALPH_DASHBOARD
export RALPH_DASHBOARD_PORT=$RALPH_DASHBOARD_PORT
export RALPH_DASHBOARD_OPEN=$RALPH_DASHBOARD_OPEN
export RALPH_PUBLIC=$RALPH_PUBLIC
export RALPH_STREAM_AI=$RALPH_STREAM_AI
export RALPH_NO_COMMIT=$RALPH_NO_COMMIT
export RALPH_USAGE_TRACKING=$RALPH_USAGE_TRACKING
export RALPH_CLAUDE="$RALPH_CLAUDE"
export RALPH_MODEL="$RALPH_MODEL"
EOF
}

load_settings() {
    local config_file="$RALPH_DIR/config.sh"
    [[ -f "$config_file" ]] && source "$config_file"
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# View: Help
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
draw_help_view() {
    get_terminal_size

    # Clear content area
    for ((i=4; i<TERM_ROWS-1; i++)); do
        move_cursor "$i" 1
        printf '%*s' "$TERM_COLS" ''
    done

    local row=5
    local col=4

    move_cursor "$row" "$col"
    printf '%s%s Help & Documentation %s' "$BOLD" "â“" "$RESET"

    draw_horizontal_line "$((row+1))" 1 "$TERM_COLS" "â”€"

    ((row += 3))

    # Keyboard shortcuts
    move_cursor "$row" "$col"
    printf '%s%sKeyboard Shortcuts%s' "$BOLD" "$UNDERLINE" "$RESET"

    local -a shortcuts=(
        "â†‘/â†“ or j/k|Navigate menus and lists"
        "Enter|Select/confirm"
        "Escape|Go back/cancel"
        "q|Quit (from main menu)"
        "?|Show this help"
        "Space|Toggle boolean settings"
        "r|Retry/reset (context-dependent)"
        "f|Filter (in logs view)"
        "c|Clear (in logs view)"
        "d|Open dashboard"
        "l|View logs"
        "s|View stories"
    )

    for shortcut in "${shortcuts[@]}"; do
        ((row++))
        IFS='|' read -r key desc <<< "$shortcut"
        move_cursor "$row" "$((col+2))"
        printf '%s%-12s%s %s' "$CYAN" "$key" "$RESET" "$desc"
    done

    ((row += 2))

    # Features overview
    move_cursor "$row" "$col"
    printf '%s%sFeatures%s' "$BOLD" "$UNDERLINE" "$RESET"

    local -a features=(
        "â€¢ Autonomous feature implementation with AI"
        "â€¢ Automatic story generation and tracking"
        "â€¢ Parallel execution with worktree isolation"
        "â€¢ Real-time web dashboard"
        "â€¢ Verification (typecheck, tests, lint)"
        "â€¢ Self-healing (story splitting on failure)"
        "â€¢ Webhook notifications (Slack, Discord)"
        "â€¢ Usage and cost tracking"
    )

    for feature in "${features[@]}"; do
        ((row++))
        move_cursor "$row" "$((col+2))"
        printf '%s' "$feature"
    done

    ((row += 2))

    # Links
    move_cursor "$row" "$col"
    printf '%s%sMore Information%s' "$BOLD" "$UNDERLINE" "$RESET"

    ((row++))
    move_cursor "$row" "$((col+2))"
    printf 'Version: %s' "$VERSION"

    ((row += 2))
    move_cursor "$row" "$col"
    printf '%sPress any key to return to the main menu%s' "$DIM" "$RESET"
}

handle_help_input() {
    local key="$1"

    case "$key" in
        ESC|q|ENTER|"")
            CURRENT_VIEW="main"
            SELECTED_INDEX=0
            ;;
    esac
    return 0
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# View: Running/Execute
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RUN_PAUSED=0
RUN_ACTIVE=0

draw_run_view() {
    get_terminal_size

    # Clear content area
    for ((i=4; i<TERM_ROWS-1; i++)); do
        move_cursor "$i" 1
        printf '%*s' "$TERM_COLS" ''
    done

    local row=5

    # Title with status
    move_cursor "$row" 2
    if ((RUN_PAUSED)); then
        printf '%s%s PAUSED %s' "$BG_YELLOW$BLACK$BOLD" "â¸" "$RESET"
    elif ((RUN_ACTIVE)); then
        draw_spinner "$row" 2
        printf '  %s%sRunning...%s' "$BOLD" "" "$RESET"
    else
        printf '%s%s Execution Complete %s' "$GREEN$BOLD" "âœ“" "$RESET"
    fi

    # Feature name
    if [[ -f "$PRD_FILE" ]]; then
        local feature_name
        feature_name=$(jq -r '.feature // "unknown"' "$PRD_FILE")
        move_cursor "$row" $((TERM_COLS - ${#feature_name} - 4))
        printf '%s%s%s' "$DIM" "$feature_name" "$RESET"
    fi

    draw_horizontal_line "$((row+1))" 1 "$TERM_COLS" "â”€"

    # Progress section
    ((row += 3))

    if [[ -f "$PRD_FILE" ]]; then
        local total done_count blocked running
        total=$(jq '.stories | length' "$PRD_FILE")
        done_count=$(jq '[.stories[] | select(.done)] | length' "$PRD_FILE")
        blocked=$(jq '[.stories[] | select(.blocked)] | length' "$PRD_FILE")
        running=$(jq '[.stories[] | select(.running)] | length' "$PRD_FILE")

        local pct=0
        ((total > 0)) && pct=$((done_count * 100 / total))

        move_cursor "$row" 2
        printf '%sProgress:%s ' "$BOLD" "$RESET"
        draw_progress_bar "$row" 12 "$((TERM_COLS - 30))" "$pct" "$done_count/$total"

        ((row += 2))
        move_cursor "$row" 2
        printf '%sâœ“ %d%s  %sâ–¶ %d%s  %sâ—‹ %d%s  %sâœ— %d%s' \
            "$GREEN" "$done_count" "$RESET" \
            "$BLUE" "$running" "$RESET" \
            "$GRAY" "$((total - done_count - blocked))" "$RESET" \
            "$RED" "$blocked" "$RESET"
    fi

    # Current story
    ((row += 3))
    local current_story
    current_story=$(jq -c '.stories[] | select(.running == true) | {id, title, tries}' "$PRD_FILE" 2>/dev/null | head -1)

    if [[ -n "$current_story" ]]; then
        local sid stitle stries
        sid=$(echo "$current_story" | jq -r '.id')
        stitle=$(echo "$current_story" | jq -r '.title')
        stries=$(echo "$current_story" | jq -r '.tries // 0')

        draw_box "$row" 2 "$((TERM_COLS - 4))" 5 "Current Story" "rounded"

        move_cursor "$((row+2))" 4
        printf '%s%s%s%s: %s' "$BOLD" "$CYAN" "$sid" "$RESET" "$(truncate_text "$stitle" $((TERM_COLS - 20)))"

        if ((stries > 0)); then
            move_cursor "$((row+2))" $((TERM_COLS - 15))
            printf '%s(attempt %d)%s' "$YELLOW" "$((stries + 1))" "$RESET"
        fi

        ((row += 6))
    fi

    # Recent output/activity
    ((row += 1))
    local remaining_height=$((TERM_ROWS - row - 3))

    if ((remaining_height > 4)); then
        draw_box "$row" 2 "$((TERM_COLS - 4))" "$remaining_height" "Recent Activity" "rounded"

        local log_start=$((row + 2))
        local log_lines=$((remaining_height - 3))

        if [[ -f "$RALPH_DIR/ralph.log" ]]; then
            local line_num=0
            while IFS= read -r line && ((line_num < log_lines)); do
                ((line_num++))
                move_cursor "$((log_start + line_num - 1))" 4

                # Color based on content
                local color="$RESET"
                if [[ "$line" == *"[ERR]"* ]]; then
                    color="$RED"
                elif [[ "$line" == *"[WARN]"* ]]; then
                    color="$YELLOW"
                elif [[ "$line" == *"[OK]"* ]]; then
                    color="$GREEN"
                fi

                printf '%s%s%s' "$color" "$(truncate_text "$line" $((TERM_COLS - 10)))" "$RESET"
            done < <(tail -"$log_lines" "$RALPH_DIR/ralph.log" 2>/dev/null)
        fi
    fi
}

handle_run_input() {
    local key="$1"

    case "$key" in
        q|Q)
            if prompt_confirm "Stop execution? Progress will be saved."; then
                RUN_ACTIVE=0
                CURRENT_VIEW="main"
                SELECTED_INDEX=0
            fi
            ;;
        p|P)
            RUN_PAUSED=$((1 - RUN_PAUSED))
            if ((RUN_PAUSED)); then
                show_notification "Execution paused" "warning" 0
            else
                show_notification "Execution resumed" "success" 30
            fi
            ;;
        l|L)
            CURRENT_VIEW="logs"
            ;;
        s|S)
            CURRENT_VIEW="stories"
            ;;
        d|D)
            open_dashboard
            ;;
    esac
    return 0
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Actions
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
start_new_feature() {
    local feature
    if ! feature=$(prompt_input "Enter feature description"); then
        return
    fi

    [[ -z "$feature" ]] && { show_notification "Feature description required" "error" 30; return; }

    if [[ -f "$PRD_FILE" ]]; then
        if ! prompt_confirm "Existing session found. Replace it?"; then
            return
        fi
        rm -f "$PRD_FILE"
    fi

    show_notification "Generating implementation plan..." "info" 0

    # Initialize workspace
    init_workspace

    # Generate PRD in background
    if generate_prd "$feature"; then
        show_notification "Plan generated! Starting execution..." "success" 30

        # Offer to start execution
        if prompt_confirm "Start executing stories now?"; then
            CURRENT_VIEW="run"
            RUN_ACTIVE=1
            run_execution_loop &
        else
            CURRENT_VIEW="stories"
        fi
    else
        show_notification "Failed to generate plan" "error" 60
    fi
}

resume_session() {
    if [[ ! -f "$PRD_FILE" ]]; then
        show_notification "No session to resume" "error" 30
        return
    fi

    normalize_prd_file "$PRD_FILE" || true

    if ! validate_prd_file "$PRD_FILE"; then
        show_notification "Invalid session file" "error" 30
        return
    fi

    local feature_name
    feature_name=$(jq -r '.feature // "unknown"' "$PRD_FILE")

    show_notification "Resuming: $feature_name" "info" 30

    if prompt_confirm "Start executing remaining stories?"; then
        CURRENT_VIEW="run"
        RUN_ACTIVE=1
        run_execution_loop &
    else
        CURRENT_VIEW="status"
    fi
}

open_dashboard() {
    if [[ -z "$DASHBOARD_PID" ]] || ! kill -0 "$DASHBOARD_PID" 2>/dev/null; then
        show_notification "Starting dashboard..." "info" 0
        start_dashboard
        sleep 1
    fi

    local url
    url=$(dashboard_url)

    if command -v open &>/dev/null; then
        open "$url" &>/dev/null
    elif command -v xdg-open &>/dev/null; then
        xdg-open "$url" &>/dev/null
    elif command -v wslview &>/dev/null; then
        wslview "$url" &>/dev/null
    fi

    show_notification "Dashboard opened: $url" "success" 30
}

reset_workspace() {
    if [[ ! -d "$RALPH_DIR" ]]; then
        show_notification "Nothing to reset" "info" 30
        return
    fi

    if ! prompt_confirm "This will delete all session data. Continue?"; then
        return
    fi

    # Stop dashboard if running
    if [[ -n "$DASHBOARD_PID" ]] && kill -0 "$DASHBOARD_PID" 2>/dev/null; then
        kill "$DASHBOARD_PID" 2>/dev/null || true
        DASHBOARD_PID=""
    fi

    rm -rf "$RALPH_DIR"
    mkdir -p "$RALPH_DIR"

    show_notification "Workspace reset complete" "success" 30
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Execution Loop (runs in background)
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
run_execution_loop() {
    local fails=0

    while ((RUN_ACTIVE)); do
        # Check for pause
        while ((RUN_PAUSED && RUN_ACTIVE)); do
            sleep 1
        done

        ((RUN_ACTIVE == 0)) && break

        # Get next story
        local next
        next=$(get_next_story)

        if [[ -z "$next" ]]; then
            local remaining
            remaining=$(remaining_count)

            if ((remaining == 0)); then
                RUN_ACTIVE=0
                show_notification "All stories complete!" "success" 60
                break
            else
                RUN_ACTIVE=0
                show_notification "No actionable stories (some may be blocked)" "warning" 60
                break
            fi
        fi

        # Execute story
        local title
        title=$(jq -r --arg id "$next" '.stories[] | select(.id == $id) | .title' "$PRD_FILE")

        mark_running "$next"
        mark_try "$next"

        _log "Starting story $next: $title"

        local result=0
        execute_story "$next" || result=$?

        if ((result == 0)); then
            if verify "$next"; then
                local commit
                commit=$(git rev-parse HEAD 2>/dev/null || echo "")
                mark_done "$next" "$commit"
                _log "Story $next complete"
                fails=0
            else
                mark_failed "$next"
                _log "Story $next failed verification"
                ((fails++))
            fi
        elif ((result == 2)); then
            _log "Story $next blocked"
            fails=0
        else
            mark_failed "$next"
            _log "Story $next incomplete"
            ((fails++))
        fi

        mark_stopped "$next"
        block_stories_with_blocked_deps

        # Too many consecutive failures
        ((fails >= 5)) && {
            RUN_ACTIVE=0
            show_notification "Too many consecutive failures" "error" 60
            break
        }

        sleep 1
    done
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Core Functions (imported from original script)
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_ts() { date '+%H:%M:%S'; }
_log() { [[ -n "$LOG_FILE" ]] && printf '[%s] %s\n' "$(_ts)" "$*" >> "$LOG_FILE"; }

slugify() {
    printf '%s' "$1" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9' '-' | sed 's/^-//;s/-$//' | cut -c1-40
}

jq_inplace() {
    local file="$1"; shift
    local tmp
    tmp=$(mktemp "${file}.tmp.XXXXXX")
    if jq "$@" "$file" > "$tmp"; then
        mv "$tmp" "$file"
    else
        rm -f "$tmp"
        return 1
    fi
}

json_extract() {
    python3 - <<'PY'
import sys, json
s = sys.stdin.read()
decoder = json.JSONDecoder()
for i, c in enumerate(s):
    if c in '{[':
        try:
            obj, _ = decoder.raw_decode(s[i:])
            print(json.dumps(obj, indent=2))
            sys.exit(0)
        except Exception:
            continue
sys.exit(1)
PY
}

with_timeout() {
    local secs="$1"; shift
    if ((secs > 0)) && ((${#TIMEOUT_CMD[@]})); then
        "${TIMEOUT_CMD[@]}" "$secs" "$@"
    else
        "$@"
    fi
}

detect_timeout_cmd() {
    if command -v timeout &>/dev/null; then
        TIMEOUT_CMD=(timeout --signal=TERM)
    elif command -v gtimeout &>/dev/null; then
        TIMEOUT_CMD=(gtimeout --signal=TERM)
    else
        TIMEOUT_CMD=()
    fi
}

detect_stack() {
    STACK="unknown"

    if [[ -f package.json ]]; then
        STACK="node"
        [[ -f bun.lockb || -f bun.lock ]] && PKG_MGR="bun"
        [[ -f pnpm-lock.yaml ]] && PKG_MGR="pnpm"
        [[ -f yarn.lock ]] && PKG_MGR="yarn"
        : "${PKG_MGR:=npm}"

        local run="$PKG_MGR run"
        [[ "$PKG_MGR" == "bun" ]] && run="bun run"

        jq -e '.scripts.test' package.json &>/dev/null && TEST_CMD="$run test"
        jq -e '.scripts.typecheck' package.json &>/dev/null && TYPE_CMD="$run typecheck"
        jq -e '.scripts.lint' package.json &>/dev/null && LINT_CMD="$run lint"
        jq -e '.scripts.build' package.json &>/dev/null && BUILD_CMD="$run build"
        jq -e '.scripts.format' package.json &>/dev/null && FMT_CMD="$run format"

        [[ -z "$TYPE_CMD" && -f tsconfig.json ]] && TYPE_CMD="npx tsc --noEmit"
    elif [[ -f pyproject.toml || -f setup.py || -f requirements.txt ]]; then
        STACK="python"
        [[ -f poetry.lock ]] && PKG_MGR="poetry"
        [[ -f Pipfile.lock ]] && PKG_MGR="pipenv"
        [[ -f uv.lock ]] && PKG_MGR="uv"
        : "${PKG_MGR:=pip}"

        command -v pytest &>/dev/null && TEST_CMD="pytest -q"
        command -v mypy &>/dev/null && TYPE_CMD="mypy ."
        command -v ruff &>/dev/null && { LINT_CMD="ruff check ."; FMT_CMD="ruff format --check ."; }
    elif [[ -f Cargo.toml ]]; then
        STACK="rust"
        PKG_MGR="cargo"
        TEST_CMD="cargo test --quiet"
        TYPE_CMD="cargo check --quiet"
        LINT_CMD="cargo clippy --quiet -- -D warnings"
        BUILD_CMD="cargo build --quiet"
        FMT_CMD="cargo fmt --check"
    elif [[ -f go.mod ]]; then
        STACK="go"
        PKG_MGR="go"
        TEST_CMD="go test ./... -count=1"
        TYPE_CMD="go vet ./..."
        BUILD_CMD="go build ./..."
    elif [[ -f Gemfile ]]; then
        STACK="ruby"
        PKG_MGR="bundle"
        [[ -f .rspec ]] && TEST_CMD="bundle exec rspec"
    fi
}

init_workspace() {
    mkdir -p "$RALPH_DIR"
    mkdir -p "$RALPH_DIR/attempts"

    LOG_FILE="$RALPH_DIR/ralph.log"
    PRD_FILE="$RALPH_DIR/prd.json"
    SESSION_FILE="$RALPH_DIR/session.json"
    EVENTS_FILE="$RALPH_DIR/events.jsonl"

    touch "$LOG_FILE"
    printf '%s\n' "# ${BRAND_NAME} Memory" > "$RALPH_DIR/memory.md"

    detect_stack
    detect_timeout_cmd
}

normalize_prd_file() {
    local file="$1"
    [[ -f "$file" ]] || return 1

    jq_inplace "$file" '
        .feature = (if (.feature|type)=="string" and (.feature|length)>0 then .feature else "unknown" end) |
        .branch = (if (.branch|type)=="string" and (.branch|length)>0 then .branch else "ralph/feature" end) |
        .created = (.created // (now | todate)) |
        .stories = (if (.stories|type)=="array" then .stories else [] end) |
        .stories |= map(
            .id = ((.id // "") | tostring) |
            .title = (if (.title|type)=="string" then .title else "" end) |
            .why = (if (.why|type)=="string" and (.why|length)>0 then .why else (if (.title|length)>0 then ("Legacy PRD: " + .title) else "Legacy PRD story" end) end) |
            .criteria = (if (.criteria|type)=="array" and (.criteria|length)>0 then .criteria else ["(legacy) criteria missing"] end) |
            .files = (if (.files|type)=="array" then .files else [] end) |
            .deps = (if (.deps|type)=="array" then .deps else [] end) |
            .priority = (if (.priority|type)=="number" then .priority else 9999 end) |
            .done = (if (.done|type)=="boolean" then .done else false end) |
            .tries = (if (.tries|type)=="number" then .tries else 0 end) |
            .blocked = (if (.blocked|type)=="boolean" then .blocked else false end) |
            .running = (if (.running|type)=="boolean" then .running else false end) |
            .notes = (if (.notes|type)=="string" then .notes else "" end)
        )
    ' || return 1
}

validate_prd_file() {
    local file="$1"
    jq -e '
        (.feature | type == "string" and length > 0) and
        (.branch | type == "string" and length > 0) and
        (.stories | type == "array" and length > 0)
    ' "$file" &>/dev/null
}

get_next_story() {
    jq -r --argjson max "$RALPH_MAX_TRIES" '
        . as $root
        | $root.stories
        | map(select(.done == false and .blocked == false and (.running // false) == false and (.tries // 0) < $max))
        | map(select((.deps // []) | all(. as $d | ($root.stories[] | select(.id == $d) | .done))))
        | sort_by(.priority, .id)
        | .[0].id // empty
    ' "$PRD_FILE"
}

remaining_count() {
    jq '[.stories[] | select(.done == false and .blocked == false)] | length' "$PRD_FILE"
}

mark_running() {
    local id="$1"
    jq_inplace "$PRD_FILE" --arg id "$id" --arg ts "$(date -Iseconds)" '
        .stories |= map(if .id == $id then . + {running: true, startedAt: $ts} else . end)
    '
}

mark_stopped() {
    local id="$1"
    jq_inplace "$PRD_FILE" --arg id "$id" '
        .stories |= map(if .id == $id then . + {running: false} else . end)
    '
}

mark_try() {
    local id="$1"
    jq_inplace "$PRD_FILE" --arg id "$id" '
        .stories |= map(if .id == $id then .tries = ((.tries // 0) + 1) else . end)
    '
}

mark_done() {
    local id="$1" commit="${2:-}"
    jq_inplace "$PRD_FILE" --arg id "$id" --arg commit "$commit" --arg ts "$(date -Iseconds)" '
        .stories |= map(if .id == $id then . + {done: true, completedAt: $ts, commit: $commit, running: false} else . end)
    '
}

mark_failed() {
    local id="$1"
    _log "Story $id failed"
}

mark_blocked() {
    local id="$1" reason="$2"
    jq_inplace "$PRD_FILE" --arg id "$id" --arg reason "$reason" '
        .stories |= map(if .id == $id then . + {blocked: true, notes: $reason, running: false} else . end)
    '
}

block_stories_with_blocked_deps() {
    jq_inplace "$PRD_FILE" '
        . as $root
        | .stories |= map(
            if (.done == true or .blocked == true) then .
            else
                (.deps // []) as $deps
                | ($deps | map(select(. as $d | ($root.stories[] | select(.id == $d) | .blocked)))) as $blocked_deps
                | if ($blocked_deps | length) > 0 then
                    . + {blocked: true, notes: ("dependency blocked: " + ($blocked_deps | join(", ")))}
                  else .
                  end
            end
        )
    '
}

verify() {
    ((RALPH_VERIFY == 0)) && return 0
    local story_id="${1:-}"

    [[ -n "$TYPE_CMD" ]] && ! eval "$TYPE_CMD" &>/dev/null && return 1
    [[ -n "$TEST_CMD" ]] && ! eval "$TEST_CMD" &>/dev/null && return 1

    return 0
}

analyze_codebase() {
    local output=""
    local files=""

    if command -v rg &>/dev/null; then
        files=$(rg --files \
            -g "*.ts" -g "*.tsx" -g "*.js" -g "*.jsx" -g "*.py" -g "*.go" -g "*.rs" -g "*.rb" \
            -g "!**/node_modules/**" -g "!**/.git/**" -g "!**/dist/**" -g "!**/build/**" \
            -g "!**/__pycache__/**" -g "!**/.venv/**" -g "!**/target/**" -g "!**/.ralph/**" \
            2>/dev/null | head -50)
    else
        files=$(find . -type f \( \
            -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \
            -o -name "*.py" -o -name "*.go" -o -name "*.rs" -o -name "*.rb" \
            \) ! -path "*/node_modules/*" ! -path "*/.git/*" ! -path "*/dist/*" \
            2>/dev/null | sort | head -50)
    fi

    output+="## Project Structure\n\`\`\`\n$files\n\`\`\`\n\n"

    if [[ -f package.json ]]; then
        output+="## Dependencies\n\`\`\`json\n"
        output+=$(jq '{ dependencies: (.dependencies // {} | keys[:15]), devDependencies: (.devDependencies // {} | keys[:10]) }' package.json 2>/dev/null)
        output+="\n\`\`\`\n\n"
    fi

    printf '%b' "$output"
}

generate_prd() {
    local feature="$1"

    local context
    context=$(analyze_codebase)

    local criteria_items=()
    criteria_items+=("\"Specific verifiable criterion\"")
    [[ -n "$TYPE_CMD" ]] && criteria_items+=("\"${TYPE_CMD%% *} passes\"")
    [[ -n "$TEST_CMD" ]] && criteria_items+=("\"tests pass\"")
    local criteria_block
    criteria_block=$(IFS=','; printf '%s' "${criteria_items[*]}")

    local prompt="You are a principal software engineer. Create an implementation plan for an autonomous AI coding agent.

## Feature Request
$feature

## Tech Stack
- Language/Framework: $STACK
- Package Manager: ${PKG_MGR:-unknown}
- Typecheck: ${TYPE_CMD:-none}
- Test: ${TEST_CMD:-none}
- Lint: ${LINT_CMD:-none}

## Codebase
$context

## CRITICAL REQUIREMENTS

Each story must be atomic and completable in a single AI context window.

## OUTPUT (STRICT)

Return ONLY valid JSON:

{
  \"feature\": \"2-4 word name\",
  \"branch\": \"ralph/kebab-case\",
  \"stories\": [
    {
      \"id\": \"S01\",
      \"title\": \"Imperative action title\",
      \"why\": \"Brief value explanation\",
      \"criteria\": [$criteria_block],
      \"files\": [\"likely/affected/files.ts\"],
      \"deps\": [],
      \"priority\": 1
    }
  ]
}"

    local raw_file="$RALPH_DIR/prd.raw"
    local prompt_file="$RALPH_DIR/prd.prompt"
    printf '%s' "$prompt" > "$prompt_file"

    local claude_args=()
    [[ -n "$RALPH_MODEL" ]] && claude_args+=(--model "$RALPH_MODEL")

    if ! with_timeout "$RALPH_TIMEOUT" "$RALPH_CLAUDE" --print "${claude_args[@]}" < "$prompt_file" > "$raw_file" 2>>"$LOG_FILE"; then
        return 1
    fi

    if json_extract < "$raw_file" > "$PRD_FILE" 2>/dev/null; then
        jq_inplace "$PRD_FILE" '
            .created = (now | todate) |
            .stories = [.stories[] |
                . + {done: false, tries: 0, blocked: false, running: false, notes: ""}
            ]
        ' || return 1

        normalize_prd_file "$PRD_FILE" || true

        if validate_prd_file "$PRD_FILE"; then
            return 0
        fi
    fi

    return 1
}

execute_story() {
    local id="$1"
    local story
    story=$(jq -c --arg id "$id" '.stories[] | select(.id == $id)' "$PRD_FILE")
    local title
    title=$(printf '%s' "$story" | jq -r '.title')

    local claude_args=()
    ((RALPH_SAFE == 0)) && claude_args+=(--dangerously-skip-permissions)
    [[ -n "$RALPH_MODEL" ]] && claude_args+=(--model "$RALPH_MODEL")

    local prompt="# Implement: $title

## Story
$story

## Stack
- Type: $STACK
- Typecheck: ${TYPE_CMD:-none}
- Test: ${TEST_CMD:-none}

## Instructions
1. Implement the story following acceptance criteria exactly
2. Verify locally
3. Commit changes

When complete: \`RALPH_DONE:$id\`
If blocked: \`RALPH_BLOCKED:$id:reason\`"

    local output_file="$RALPH_DIR/attempts/${id}/attempt-$(date +%s).log"
    mkdir -p "$(dirname "$output_file")"

    local result=0
    printf '%s' "$prompt" | with_timeout "$RALPH_TIMEOUT" "$RALPH_CLAUDE" "${claude_args[@]}" > "$output_file" 2>&1 || result=$?

    if grep -q "RALPH_DONE:$id" "$output_file" 2>/dev/null; then
        return 0
    elif grep -q "RALPH_BLOCKED:$id" "$output_file" 2>/dev/null; then
        return 2
    fi

    return 1
}

dashboard_url() {
    local host="$RALPH_DASHBOARD_HOST"
    [[ -z "$host" || "$host" == "0.0.0.0" ]] && host="localhost"
    printf 'http://%s:%s' "$host" "$RALPH_DASHBOARD_PORT"
}

start_dashboard() {
    ((RALPH_DASHBOARD == 0)) && return 0

    # Check if already running
    if [[ -n "$DASHBOARD_PID" ]] && kill -0 "$DASHBOARD_PID" 2>/dev/null; then
        return 0
    fi

    EVENTS_FILE="$RALPH_DIR/events.jsonl"
    touch "$EVENTS_FILE"

    # Simple Python dashboard server
    local server_script="$RALPH_DIR/dashboard_server.py"
    cat > "$server_script" << 'PYEOF'
import http.server, socketserver, os, threading, time
from pathlib import Path

PORT = int(os.environ.get("RALPH_DASHBOARD_PORT", 3333))
EVENTS_FILE = os.environ.get("RALPH_EVENTS_FILE", ".ralph/events.jsonl")

class Handler(http.server.SimpleHTTPRequestHandler):
    def log_message(self, *a): pass
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.end_headers()
            self.wfile.write(b"<html><body><h1>RALPH Dashboard</h1><p>Running...</p></body></html>")
        else:
            self.send_response(404)
            self.end_headers()

class ThreadingTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    allow_reuse_address = True

try:
    with ThreadingTCPServer(("127.0.0.1", PORT), Handler) as h:
        h.serve_forever()
except:
    pass
PYEOF

    RALPH_DASHBOARD_PORT="$RALPH_DASHBOARD_PORT" RALPH_EVENTS_FILE="$EVENTS_FILE" \
        python3 "$server_script" &>/dev/null &
    DASHBOARD_PID=$!

    sleep 0.5
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Global Installation
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
install_globally() {
    local install_dir="${1:-}"
    local script_path="$0"

    # Determine install location
    if [[ -z "$install_dir" ]]; then
        # Try common locations in order of preference
        local -a candidates=(
            "$HOME/.local/bin"
            "$HOME/bin"
            "/usr/local/bin"
        )

        for dir in "${candidates[@]}"; do
            if [[ -d "$dir" ]] && [[ -w "$dir" ]]; then
                install_dir="$dir"
                break
            fi
        done

        # Create ~/.local/bin if nothing found
        if [[ -z "$install_dir" ]]; then
            install_dir="$HOME/.local/bin"
            mkdir -p "$install_dir"
        fi
    fi

    local target="$install_dir/ralph"

    echo ""
    echo "  ${CYAN}${BOLD}Installing RALPH globally...${RESET}"
    echo ""

    # Copy script
    if cp "$script_path" "$target" 2>/dev/null; then
        chmod +x "$target"
        echo "  ${GREEN}âœ“${RESET} Installed to: ${BOLD}$target${RESET}"
    else
        # Try with sudo
        echo "  ${YELLOW}âš ${RESET} Permission denied. Trying with sudo..."
        if sudo cp "$script_path" "$target" && sudo chmod +x "$target"; then
            echo "  ${GREEN}âœ“${RESET} Installed to: ${BOLD}$target${RESET}"
        else
            echo "  ${RED}âœ—${RESET} Failed to install. Please run with sudo or specify a writable directory."
            exit 1
        fi
    fi

    # Check if in PATH
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then
        echo ""
        echo "  ${YELLOW}âš ${RESET} $install_dir is not in your PATH."
        echo ""
        echo "  Add this to your shell config (~/.bashrc, ~/.zshrc, etc.):"
        echo ""
        echo "    ${DIM}export PATH=\"\$PATH:$install_dir\"${RESET}"
        echo ""
    fi

    echo ""
    echo "  ${GREEN}${BOLD}Installation complete!${RESET}"
    echo ""
    echo "  Run ${CYAN}ralph${RESET} from any directory to start."
    echo ""
}

uninstall_globally() {
    local -a locations=(
        "$HOME/.local/bin/ralph"
        "$HOME/bin/ralph"
        "/usr/local/bin/ralph"
    )

    local found=0

    echo ""
    echo "  ${CYAN}${BOLD}Uninstalling RALPH...${RESET}"
    echo ""

    for loc in "${locations[@]}"; do
        if [[ -f "$loc" ]]; then
            if rm "$loc" 2>/dev/null || sudo rm "$loc" 2>/dev/null; then
                echo "  ${GREEN}âœ“${RESET} Removed: $loc"
                found=1
            fi
        fi
    done

    # Also remove config directory
    if [[ -d "$HOME/.ralph-global" ]]; then
        rm -rf "$HOME/.ralph-global"
        echo "  ${GREEN}âœ“${RESET} Removed global config: $HOME/.ralph-global"
    fi

    if ((found == 0)); then
        echo "  ${YELLOW}âš ${RESET} No global installation found."
    else
        echo ""
        echo "  ${GREEN}${BOLD}Uninstallation complete!${RESET}"
    fi
    echo ""
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Onboarding System
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ONBOARDING_TOTAL_STEPS=7

check_onboarding_needed() {
    ONBOARDING_FILE="$HOME/.ralph-onboarding-complete"
    [[ -f "$ONBOARDING_FILE" ]] && ONBOARDING_COMPLETE=1 || ONBOARDING_COMPLETE=0
}

mark_onboarding_complete() {
    echo "$(date -Iseconds)" > "$ONBOARDING_FILE"
    ONBOARDING_COMPLETE=1
}

draw_onboarding_progress() {
    local step=$1
    local total=$ONBOARDING_TOTAL_STEPS

    get_terminal_size
    local row=$((TERM_ROWS - 3))
    local width=$((TERM_COLS - 20))
    local col=10

    move_cursor "$row" "$col"
    printf '%sStep %d of %d%s' "$DIM" "$step" "$total" "$RESET"

    local filled=$((step * width / total))
    local empty=$((width - filled))

    move_cursor "$((row + 1))" "$col"
    printf '['
    printf '%s%*s%s' "$CYAN" "$filled" '' "$RESET" | tr ' ' 'â–ˆ'
    printf '%s%*s%s' "$DIM" "$empty" '' "$RESET" | tr ' ' 'â–‘'
    printf ']'
}

draw_onboarding_welcome() {
    get_terminal_size
    printf '%s%s' "$HOME" "$CLEAR_SCREEN"

    local row=3

    # Animated logo reveal
    local logo=(
        "    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—"
        "    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘"
        "    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘"
        "    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘"
        "    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘"
        "    â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•  â•šâ•â•"
    )

    printf '%s' "$CYAN$BOLD"
    for ((i=0; i<${#logo[@]}; i++)); do
        move_cursor "$((row + i))" "$(( (TERM_COLS - 46) / 2 ))"
        printf '%s' "${logo[$i]}"
        sleep 0.05
    done
    printf '%s' "$RESET"

    row=$((row + 8))

    move_cursor "$row" 1
    printf '%s' "$BOLD"
    center_text "Welcome to DAVAI" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 2))
    move_cursor "$row" 1
    printf '%s' "$DIM"
    center_text "Ğ´Ğ°Ğ²Ğ°Ğ¹, Ñ€Ğ°Ğ»ÑŒÑ„, Ğ´Ğ°Ğ²Ğ°Ğ¹!" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 4))

    local box_width=60
    local box_col=$(( (TERM_COLS - box_width) / 2 ))

    draw_box "$row" "$box_col" "$box_width" 10 "" "rounded"

    ((row += 2))
    move_cursor "$row" "$((box_col + 3))"
    printf '%sâœ¨%s DAVAI helps you build features autonomously' "$YELLOW" "$RESET"

    ((row += 2))
    move_cursor "$row" "$((box_col + 3))"
    printf '%sğŸ“‹%s Generates implementation plans from descriptions' "$BLUE" "$RESET"

    ((row += 2))
    move_cursor "$row" "$((box_col + 3))"
    printf '%sğŸ¤–%s Executes stories with AI-powered coding' "$CYAN" "$RESET"

    ((row += 2))
    move_cursor "$row" "$((box_col + 3))"
    printf '%sâœ“%s  Verifies changes with your test suite' "$GREEN" "$RESET"

    draw_onboarding_progress 1

    move_cursor "$((TERM_ROWS - 1))" 1
    center_text "Press ENTER to continue, or ESC to skip onboarding" "$TERM_COLS"
}

draw_onboarding_requirements() {
    get_terminal_size
    printf '%s%s' "$HOME" "$CLEAR_SCREEN"

    local row=4

    move_cursor "$row" 1
    printf '%s' "$BOLD$CYAN"
    center_text "ğŸ” Checking Requirements" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 3))

    local box_width=70
    local box_col=$(( (TERM_COLS - box_width) / 2 ))

    draw_box "$row" "$box_col" "$box_width" 16 "System Check" "rounded"

    local check_row=$((row + 2))
    local label_col=$((box_col + 4))
    local status_col=$((box_col + box_width - 15))

    # Check each requirement with animation
    local -a requirements=(
        "jq|JSON processor|brew install jq"
        "git|Version control|brew install git"
        "python3|Python runtime|brew install python3"
        "claude|Claude CLI|npm install -g @anthropic-ai/claude-code"
    )

    for req_line in "${requirements[@]}"; do
        IFS='|' read -r cmd desc install_cmd <<< "$req_line"

        move_cursor "$check_row" "$label_col"
        printf '%s%-25s%s %s' "$BOLD" "$cmd" "$RESET" "$DIM$desc$RESET"

        move_cursor "$check_row" "$status_col"
        printf '%sâ‹¯%s checking' "$YELLOW" "$RESET"
        sleep 0.3

        move_cursor "$check_row" "$status_col"
        if command -v "$cmd" &>/dev/null; then
            local ver=""
            case "$cmd" in
                jq) ver=$(jq --version 2>/dev/null | head -1) ;;
                git) ver=$(git --version 2>/dev/null | awk '{print $3}') ;;
                python3) ver=$(python3 --version 2>/dev/null | awk '{print $2}') ;;
                claude) ver="installed" ;;
            esac
            printf '%sâœ“%s %-10s' "$GREEN" "$RESET" "$ver"
        else
            printf '%sâœ—%s missing   ' "$RED" "$RESET"

            # Show install hint
            ((check_row += 1))
            move_cursor "$check_row" "$((label_col + 2))"
            printf '%sâ†’ %s%s' "$DIM" "$install_cmd" "$RESET"
        fi

        ((check_row += 2))
    done

    # Additional checks
    move_cursor "$check_row" "$label_col"
    printf '%s%-25s%s' "$BOLD" "Terminal" "$RESET"
    move_cursor "$check_row" "$status_col"
    printf '%sâœ“%s %s' "$GREEN" "$RESET" "${TERM:-unknown}"

    ((check_row += 2))
    move_cursor "$check_row" "$label_col"
    printf '%s%-25s%s' "$BOLD" "Shell" "$RESET"
    move_cursor "$check_row" "$status_col"
    printf '%sâœ“%s %s' "$GREEN" "$RESET" "${SHELL##*/}"

    draw_onboarding_progress 2

    move_cursor "$((TERM_ROWS - 1))" 1
    center_text "Press ENTER to continue" "$TERM_COLS"
}

draw_onboarding_project_detection() {
    get_terminal_size
    printf '%s%s' "$HOME" "$CLEAR_SCREEN"

    local row=4

    move_cursor "$row" 1
    printf '%s' "$BOLD$CYAN"
    center_text "ğŸ“ Project Detection" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 2))
    move_cursor "$row" 1
    printf '%s' "$DIM"
    center_text "Current directory: $LAUNCH_DIR" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 3))

    local box_width=70
    local box_col=$(( (TERM_COLS - box_width) / 2 ))

    draw_box "$row" "$box_col" "$box_width" 14 "Detected Stack" "rounded"

    # Detect and display
    detect_stack

    local info_row=$((row + 2))
    local label_col=$((box_col + 4))

    move_cursor "$info_row" "$label_col"
    if [[ "$STACK" != "unknown" ]]; then
        printf '%sâœ“%s Stack detected: %s%s%s' "$GREEN" "$RESET" "$BOLD$CYAN" "$STACK" "$RESET"
    else
        printf '%sâš %s No recognized stack in current directory' "$YELLOW" "$RESET"
    fi

    ((info_row += 2))
    move_cursor "$info_row" "$label_col"
    printf '%sPackage Manager:%s %s' "$BOLD" "$RESET" "${PKG_MGR:-not detected}"

    ((info_row += 2))

    # Verification commands
    move_cursor "$info_row" "$label_col"
    printf '%sVerification Commands:%s' "$BOLD$UNDERLINE" "$RESET"

    ((info_row += 1))
    move_cursor "$info_row" "$((label_col + 2))"
    if [[ -n "$TYPE_CMD" ]]; then
        printf '%sâœ“%s Typecheck: %s%s%s' "$GREEN" "$RESET" "$DIM" "$TYPE_CMD" "$RESET"
    else
        printf '%sâ—‹%s Typecheck: %snot configured%s' "$GRAY" "$RESET" "$DIM" "$RESET"
    fi

    ((info_row += 1))
    move_cursor "$info_row" "$((label_col + 2))"
    if [[ -n "$TEST_CMD" ]]; then
        printf '%sâœ“%s Tests:     %s%s%s' "$GREEN" "$RESET" "$DIM" "$TEST_CMD" "$RESET"
    else
        printf '%sâ—‹%s Tests:     %snot configured%s' "$GRAY" "$RESET" "$DIM" "$RESET"
    fi

    ((info_row += 1))
    move_cursor "$info_row" "$((label_col + 2))"
    if [[ -n "$LINT_CMD" ]]; then
        printf '%sâœ“%s Lint:      %s%s%s' "$GREEN" "$RESET" "$DIM" "$LINT_CMD" "$RESET"
    else
        printf '%sâ—‹%s Lint:      %snot configured%s' "$GRAY" "$RESET" "$DIM" "$RESET"
    fi

    draw_onboarding_progress 3

    move_cursor "$((TERM_ROWS - 1))" 1
    center_text "Press ENTER to continue" "$TERM_COLS"
}

draw_onboarding_modes() {
    get_terminal_size
    printf '%s%s' "$HOME" "$CLEAR_SCREEN"

    local row=4

    move_cursor "$row" 1
    printf '%s' "$BOLD$CYAN"
    center_text "âš¡ Operating Modes" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 3))

    local box_width=70
    local box_col=$(( (TERM_COLS - box_width) / 2 ))

    # Safe Mode
    draw_box "$row" "$box_col" "$box_width" 6 "Safe Mode (Default)" "rounded"

    local info_row=$((row + 2))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%sğŸ›¡ï¸%s  AI asks permission before making changes' "$GREEN" "$RESET"
    ((info_row += 1))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%s%s  Best for: learning, sensitive projects%s' "$DIM" "" "$RESET"

    ((row += 8))

    # YOLO Mode
    draw_box "$row" "$box_col" "$box_width" 6 "YOLO Mode" "rounded"

    info_row=$((row + 2))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%sğŸš€%s  Maximum autonomy, parallel agents, auto-approve' "$YELLOW" "$RESET"
    ((info_row += 1))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%s%s  Best for: trusted projects, experienced users%s' "$DIM" "" "$RESET"

    ((row += 8))

    # Parallel Mode
    draw_box "$row" "$box_col" "$box_width" 6 "Parallel Execution" "rounded"

    info_row=$((row + 2))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%sâš¡%s  Run multiple stories simultaneously with worktrees' "$CYAN" "$RESET"
    ((info_row += 1))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%s%s  Configurable in Settings â†’ Parallel Agents%s' "$DIM" "" "$RESET"

    draw_onboarding_progress 4

    move_cursor "$((TERM_ROWS - 1))" 1
    center_text "Press ENTER to continue" "$TERM_COLS"
}

draw_onboarding_workflow() {
    get_terminal_size
    printf '%s%s' "$HOME" "$CLEAR_SCREEN"

    local row=4

    move_cursor "$row" 1
    printf '%s' "$BOLD$CYAN"
    center_text "ğŸ”„ How It Works" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 3))

    local box_width=70
    local box_col=$(( (TERM_COLS - box_width) / 2 ))

    draw_box "$row" "$box_col" "$box_width" 20 "Workflow" "rounded"

    local step_row=$((row + 2))
    local step_col=$((box_col + 6))

    # Step 1
    move_cursor "$step_row" "$step_col"
    printf '%s%s1%s' "$BG_CYAN$BLACK$BOLD" " " "$RESET"
    printf '  %sDescribe Your Feature%s' "$BOLD" "$RESET"
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 4))"
    printf '%s"Add user authentication with OAuth"%s' "$DIM$ITALIC" "$RESET"

    # Arrow
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 2))"
    printf '%sâ†“%s' "$CYAN" "$RESET"

    # Step 2
    ((step_row += 1))
    move_cursor "$step_row" "$step_col"
    printf '%s%s2%s' "$BG_CYAN$BLACK$BOLD" " " "$RESET"
    printf '  %sRALPH Generates Stories%s' "$BOLD" "$RESET"
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 4))"
    printf '%sBreaks feature into atomic, verifiable tasks%s' "$DIM" "$RESET"

    # Arrow
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 2))"
    printf '%sâ†“%s' "$CYAN" "$RESET"

    # Step 3
    ((step_row += 1))
    move_cursor "$step_row" "$step_col"
    printf '%s%s3%s' "$BG_CYAN$BLACK$BOLD" " " "$RESET"
    printf '  %sAI Implements Each Story%s' "$BOLD" "$RESET"
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 4))"
    printf '%sClaude writes code, runs verification%s' "$DIM" "$RESET"

    # Arrow
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 2))"
    printf '%sâ†“%s' "$CYAN" "$RESET"

    # Step 4
    ((step_row += 1))
    move_cursor "$step_row" "$step_col"
    printf '%s%s4%s' "$BG_CYAN$BLACK$BOLD" " " "$RESET"
    printf '  %sVerify & Commit%s' "$BOLD" "$RESET"
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 4))"
    printf '%sTypecheck, tests, lint â†’ auto-commit on success%s' "$DIM" "$RESET"

    # Arrow
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 2))"
    printf '%sâ†“%s' "$CYAN" "$RESET"

    # Step 5
    ((step_row += 1))
    move_cursor "$step_row" "$step_col"
    printf '%s%s5%s' "$BG_GREEN$BLACK$BOLD" " " "$RESET"
    printf '  %sFeature Complete!%s' "$BOLD$GREEN" "$RESET"
    ((step_row += 1))
    move_cursor "$step_row" "$((step_col + 4))"
    printf '%sPR summary generated, ready for review%s' "$DIM" "$RESET"

    draw_onboarding_progress 5

    move_cursor "$((TERM_ROWS - 1))" 1
    center_text "Press ENTER to continue" "$TERM_COLS"
}

draw_onboarding_keyboard() {
    get_terminal_size
    printf '%s%s' "$HOME" "$CLEAR_SCREEN"

    local row=4

    move_cursor "$row" 1
    printf '%s' "$BOLD$CYAN"
    center_text "âŒ¨ï¸  Keyboard Shortcuts" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 3))

    local box_width=70
    local box_col=$(( (TERM_COLS - box_width) / 2 ))

    draw_box "$row" "$box_col" "$box_width" 18 "Quick Reference" "rounded"

    local key_row=$((row + 2))
    local key_col=$((box_col + 4))
    local desc_col=$((box_col + 20))

    local -a shortcuts=(
        "â†‘ / â†“|Navigate menus and lists"
        "Enter|Select or confirm"
        "Escape|Go back or cancel"
        "q|Quit application"
        "?|Show help"
        "Space|Toggle options"
        "r|Retry / Reset"
        "f|Filter (in logs)"
        "d|Open dashboard"
        "l|View logs"
        "s|View stories"
        "p|Pause execution"
    )

    for shortcut in "${shortcuts[@]}"; do
        IFS='|' read -r key desc <<< "$shortcut"

        move_cursor "$key_row" "$key_col"
        printf '%s%s%-12s%s' "$BG_GRAY$WHITE" "" "$key" "$RESET"

        move_cursor "$key_row" "$desc_col"
        printf '%s' "$desc"

        ((key_row += 1))
    done

    draw_onboarding_progress 6

    move_cursor "$((TERM_ROWS - 1))" 1
    center_text "Press ENTER to continue" "$TERM_COLS"
}

draw_onboarding_ready() {
    get_terminal_size
    printf '%s%s' "$HOME" "$CLEAR_SCREEN"

    local row=5

    # Big checkmark
    move_cursor "$row" 1
    printf '%s' "$GREEN$BOLD"
    center_text "âœ“" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 2))
    move_cursor "$row" 1
    printf '%s' "$BOLD"
    center_text "You're All Set!" "$TERM_COLS"
    printf '%s' "$RESET"

    ((row += 4))

    local box_width=60
    local box_col=$(( (TERM_COLS - box_width) / 2 ))

    draw_box "$row" "$box_col" "$box_width" 12 "Quick Start" "double"

    local info_row=$((row + 2))

    move_cursor "$info_row" "$((box_col + 4))"
    printf '%s1.%s Select %s"Start New Feature"%s from the menu' "$CYAN$BOLD" "$RESET" "$BOLD" "$RESET"

    ((info_row += 2))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%s2.%s Describe what you want to build' "$CYAN$BOLD" "$RESET"

    ((info_row += 2))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%s3.%s Watch RALPH work its magic!' "$CYAN$BOLD" "$RESET"

    ((info_row += 3))
    move_cursor "$info_row" "$((box_col + 4))"
    printf '%sTip: Press %s?%s anytime for help%s' "$DIM" "$BOLD" "$DIM" "$RESET"

    draw_onboarding_progress 7

    move_cursor "$((TERM_ROWS - 1))" 1
    center_text "Press ENTER to start using RALPH" "$TERM_COLS"
}

run_onboarding() {
    ONBOARDING_STEP=1

    while ((ONBOARDING_STEP <= ONBOARDING_TOTAL_STEPS)); do
        case $ONBOARDING_STEP in
            1) draw_onboarding_welcome ;;
            2) draw_onboarding_requirements ;;
            3) draw_onboarding_project_detection ;;
            4) draw_onboarding_modes ;;
            5) draw_onboarding_workflow ;;
            6) draw_onboarding_keyboard ;;
            7) draw_onboarding_ready ;;
        esac

        local key
        key=$(read_key 30)

        case "$key" in
            ENTER|"")
                ((ONBOARDING_STEP++))
                ;;
            ESC)
                # Skip onboarding
                break
                ;;
            LEFT|UP)
                ((ONBOARDING_STEP > 1)) && ((ONBOARDING_STEP--))
                ;;
        esac
    done

    mark_onboarding_complete
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main TUI Loop
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cleanup_tui() {
    printf '%s%s%s' "$ALT_SCREEN_OFF" "$SHOW_CURSOR" "$RESET"
    stty echo 2>/dev/null || true

    # Stop dashboard
    if [[ -n "$DASHBOARD_PID" ]] && kill -0 "$DASHBOARD_PID" 2>/dev/null; then
        kill "$DASHBOARD_PID" 2>/dev/null || true
    fi
}

tui_main() {
    # Setup
    printf '%s%s' "$ALT_SCREEN_ON" "$HIDE_CURSOR"
    stty -echo 2>/dev/null || true

    trap cleanup_tui EXIT INT TERM

    TUI_ACTIVE=1
    CURRENT_VIEW="main"
    SELECTED_INDEX=0

    # Initialize workspace paths
    if [[ "$RALPH_DIR" != /* ]]; then
        RALPH_DIR="$RALPH_ROOT/$RALPH_DIR"
    fi

    PRD_FILE="$RALPH_DIR/prd.json"
    LOG_FILE="$RALPH_DIR/ralph.log"
    SESSION_FILE="$RALPH_DIR/session.json"

    mkdir -p "$RALPH_DIR"
    load_settings
    detect_stack

    # Check if onboarding needed
    check_onboarding_needed
    if ((ONBOARDING_COMPLETE == 0)); then
        run_onboarding
    fi

    # Main loop
    while ((TUI_ACTIVE)); do
        get_terminal_size

        # Clear and draw
        printf '%s%s' "$HOME" "$CLEAR_SCREEN"

        draw_header

        case "$CURRENT_VIEW" in
            main)
                draw_main_menu
                ;;
            stories)
                draw_stories_view
                ;;
            status)
                draw_status_view
                ;;
            logs)
                draw_logs_view
                ;;
            settings)
                draw_settings_view
                ;;
            help)
                draw_help_view
                ;;
            run)
                draw_run_view
                ;;
        esac

        draw_footer
        draw_notification

        # Handle input
        local key
        key=$(read_key "$TUI_REFRESH_RATE")

        if [[ -n "$key" ]]; then
            case "$CURRENT_VIEW" in
                main)
                    handle_main_menu_input "$key" || TUI_ACTIVE=0
                    ;;
                stories)
                    handle_stories_input "$key"
                    ;;
                status)
                    handle_status_input "$key"
                    ;;
                logs)
                    handle_logs_input "$key"
                    ;;
                settings)
                    handle_settings_input "$key"
                    ;;
                help)
                    handle_help_input "$key"
                    ;;
                run)
                    handle_run_input "$key"
                    ;;
            esac
        fi
    done
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Entry Point
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
show_banner() {
    printf '%s' "$CYAN"
    cat << 'BANNER'

    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
    â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•  â•šâ•â•â•â•  â•šâ•â•  â•šâ•â•â•šâ•â•

BANNER
    printf '%s    Ğ´Ğ°Ğ²Ğ°Ğ¹, Ñ€Ğ°Ğ»ÑŒÑ„, Ğ´Ğ°Ğ²Ğ°Ğ¹! ğŸš€%s\n\n' "$DIM" "$RESET"
}

main() {
    # Handle CLI args before TUI
    case "${1:-}" in
        -h|--help)
            show_banner
            cat << EOF
${BOLD}${BRAND_NAME} v$VERSION${RESET} - Autonomous AI Coding Orchestrator

${BOLD}Usage:${RESET}
  $SCRIPT_NAME                     Launch interactive TUI
  $SCRIPT_NAME --install [DIR]     Install globally (default: ~/.local/bin)
  $SCRIPT_NAME --uninstall         Remove global installation
  $SCRIPT_NAME --onboarding        Run onboarding again
  $SCRIPT_NAME --reset-onboarding  Reset onboarding state
  $SCRIPT_NAME --version           Show version
  $SCRIPT_NAME --help              Show this help

${BOLD}Quick Start:${RESET}
  1. Run ${CYAN}davai${RESET} in your project directory
  2. Select "Start New Feature"
  3. Describe what you want to build
  4. Let the AI do the work!

${BOLD}Features:${RESET}
  â€¢ AI-powered autonomous coding
  â€¢ Story-based implementation planning
  â€¢ Parallel execution with git worktrees
  â€¢ Real-time web dashboard
  â€¢ Automatic verification (typecheck, tests, lint)
  â€¢ Self-healing (story splitting on failure)
  â€¢ Webhook notifications (Slack, Discord)

${BOLD}Environment Variables:${RESET}
  RALPH_CLAUDE        Claude binary (default: claude)
  RALPH_MODEL         Model override
  RALPH_MAX_ITER      Max iterations (default: 100)
  RALPH_PARALLEL      Parallel agents (default: 1)
  RALPH_TIMEOUT       Timeout in seconds (default: 600)
  RALPH_SAFE          Safe mode (default: 1)
  RALPH_DASHBOARD     Enable dashboard (default: 1)
  RALPH_WEBHOOK       Webhook URL for notifications

${BOLD}More Info:${RESET}
  Press ${CYAN}?${RESET} in the TUI for keyboard shortcuts

${DIM}Ğ´Ğ°Ğ²Ğ°Ğ¹, Ñ€Ğ°Ğ»ÑŒÑ„, Ğ´Ğ°Ğ²Ğ°Ğ¹!${RESET}
EOF
            exit 0
            ;;
        -v|--version)
            show_banner
            printf '  Version: %s\n\n' "$VERSION"
            exit 0
            ;;
        --install)
            show_banner
            install_globally "${2:-}"
            exit 0
            ;;
        --uninstall)
            show_banner
            uninstall_globally
            exit 0
            ;;
        --onboarding)
            # Force run onboarding
            printf '%s%s' "$ALT_SCREEN_ON" "$HIDE_CURSOR"
            stty -echo 2>/dev/null || true
            trap 'printf "%s%s%s" "$ALT_SCREEN_OFF" "$SHOW_CURSOR" "$RESET"; stty echo 2>/dev/null' EXIT
            ONBOARDING_COMPLETE=0
            run_onboarding
            exit 0
            ;;
        --reset-onboarding)
            rm -f "$HOME/.ralph-onboarding-complete"
            printf '%sâœ“%s Onboarding reset. Run %sdavai%s to start fresh.\n' "$GREEN" "$RESET" "$CYAN" "$RESET"
            exit 0
            ;;
    esac

    # Check requirements
    local missing=0
    for cmd in jq git python3; do
        if ! command -v "$cmd" &>/dev/null; then
            printf '%sâœ—%s Missing required command: %s\n' "$RED" "$RESET" "$cmd"
            missing=1
        fi
    done
    ((missing)) && exit 1

    # Launch TUI
    tui_main
}

main "$@"
